// Package clusters provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.2.0 DO NOT EDIT.
package clusters

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"github.com/NexGenCloud/hyperstack-sdk-go/lib/time"

	"github.com/oapi-codegen/runtime"
)

// Defines values for CreateClusterNodeFieldsRole.
const (
	Master CreateClusterNodeFieldsRole = "master"
	Worker CreateClusterNodeFieldsRole = "worker"
)

// Defines values for CreateClusterPayloadDeploymentMode.
const (
	Full     CreateClusterPayloadDeploymentMode = "full"
	Standard CreateClusterPayloadDeploymentMode = "standard"
)

// ClusterFields defines model for ClusterFields.
type ClusterFields struct {
	ApiAddress        *string                   `json:"api_address,omitempty"`
	CreatedAt         *time.CustomTime                `json:"created_at,omitempty"`
	EnvironmentName   *string                   `json:"environment_name,omitempty"`
	Id                *int                      `json:"id,omitempty"`
	KeypairName       *string                   `json:"keypair_name,omitempty"`
	KubeConfig        *string                   `json:"kube_config,omitempty"`
	KubernetesVersion *string                   `json:"kubernetes_version,omitempty"`
	MasterFlavor      *ClusterFlavorFields      `json:"master_flavor,omitempty"`
	Name              *string                   `json:"name,omitempty"`
	NodeGroups        *[]ClusterNodeGroupFields `json:"node_groups,omitempty"`
	Nodes             *[]ClusterNodeFields      `json:"nodes,omitempty"`
	Status            *string                   `json:"status,omitempty"`
	StatusReason      *string                   `json:"status_reason,omitempty"`
}

// ClusterListResponse defines model for ClusterListResponse.
type ClusterListResponse struct {
	Clusters *[]ClusterFields `json:"clusters,omitempty"`
	Message  *string          `json:"message,omitempty"`
	Status   *bool            `json:"status,omitempty"`
}

// ClusterNodeFields defines model for ClusterNodeFields.
type ClusterNodeFields struct {
	CreatedAt        *time.CustomTime                 `json:"created_at,omitempty"`
	Id               *int                       `json:"id,omitempty"`
	Instance         *ClusterNodeInstanceFields `json:"instance,omitempty"`
	IsBastion        *bool                      `json:"is_bastion,omitempty"`
	NodeGroupId      *int                       `json:"node_group_id,omitempty"`
	NodeGroupName    *string                    `json:"node_group_name,omitempty"`
	RequiresPublicIp *bool                      `json:"requires_public_ip,omitempty"`
	Role             *string                    `json:"role,omitempty"`
	Status           *string                    `json:"status,omitempty"`
	StatusReason     *string                    `json:"status_reason,omitempty"`
	UpdatedAt        *time.CustomTime                 `json:"updated_at,omitempty"`
}

// ClusterNodeGroupFields defines model for ClusterNodeGroupFields.
type ClusterNodeGroupFields struct {
	Count     *int                 `json:"count,omitempty"`
	CreatedAt *time.CustomTime           `json:"created_at,omitempty"`
	Flavor    *ClusterFlavorFields `json:"flavor,omitempty"`
	Id        *int                 `json:"id,omitempty"`
	Name      *string              `json:"name,omitempty"`
	Role      *string              `json:"role,omitempty"`
	UpdatedAt *time.CustomTime           `json:"updated_at,omitempty"`
}

// ClusterNodeGroupsCreateResponse defines model for ClusterNodeGroupsCreateResponse.
type ClusterNodeGroupsCreateResponse struct {
	Message   *string                 `json:"message,omitempty"`
	NodeGroup *ClusterNodeGroupFields `json:"node_group,omitempty"`
	Nodes     *[]ClusterNodeFields    `json:"nodes,omitempty"`
	Status    *bool                   `json:"status,omitempty"`
}

// ClusterNodeGroupsGetResponse defines model for ClusterNodeGroupsGetResponse.
type ClusterNodeGroupsGetResponse struct {
	Message   *string                 `json:"message,omitempty"`
	NodeGroup *ClusterNodeGroupFields `json:"node_group,omitempty"`
	Status    *bool                   `json:"status,omitempty"`
}

// ClusterNodeGroupsListResponse defines model for ClusterNodeGroupsListResponse.
type ClusterNodeGroupsListResponse struct {
	Message    *string                   `json:"message,omitempty"`
	NodeGroups *[]ClusterNodeGroupFields `json:"node_groups,omitempty"`
	Status     *bool                     `json:"status,omitempty"`
}

// ClusterNodeInstanceFields defines model for ClusterNodeInstanceFields.
type ClusterNodeInstanceFields struct {
	ContractId       *int    `json:"contract_id,omitempty"`
	FixedIp          *string `json:"fixed_ip,omitempty"`
	FloatingIp       *string `json:"floating_ip,omitempty"`
	FloatingIpStatus *string `json:"floating_ip_status,omitempty"`
	Id               *int    `json:"id,omitempty"`
	ImageId          *int    `json:"image_id,omitempty"`
	Name             *string `json:"name,omitempty"`
	Status           *string `json:"status,omitempty"`
}

// ClusterNodesListResponse defines model for ClusterNodesListResponse.
type ClusterNodesListResponse struct {
	Message *string              `json:"message,omitempty"`
	Nodes   *[]ClusterNodeFields `json:"nodes,omitempty"`
	Status  *bool                `json:"status,omitempty"`
}

// ClusterResponse defines model for ClusterResponse.
type ClusterResponse struct {
	Cluster *ClusterFields `json:"cluster,omitempty"`
	Message *string        `json:"message,omitempty"`
	Status  *bool          `json:"status,omitempty"`
}

// ClusterVersion defines model for ClusterVersion.
type ClusterVersion struct {
	CreatedAt *time.CustomTime `json:"created_at,omitempty"`
	Id        *int       `json:"id,omitempty"`
	Image     *Image     `json:"image,omitempty"`
	Region    *Region    `json:"region,omitempty"`
	UpdatedAt *time.CustomTime `json:"updated_at,omitempty"`
	Version   *string    `json:"version,omitempty"`
}

// ClusterVersions defines model for ClusterVersions.
type ClusterVersions struct {
	Message  *string           `json:"message,omitempty"`
	Status   *bool             `json:"status,omitempty"`
	Versions *[]ClusterVersion `json:"versions,omitempty"`
}

// ClusterFlavorFields defines model for Cluster_Flavor_Fields.
type ClusterFlavorFields struct {
	Cpu       *int                    `json:"cpu,omitempty"`
	Disk      *int                    `json:"disk,omitempty"`
	Ephemeral *int                    `json:"ephemeral,omitempty"`
	Features  *map[string]interface{} `json:"features,omitempty"`
	Gpu       *string                 `json:"gpu,omitempty"`
	GpuCount  *int                    `json:"gpu_count,omitempty"`
	Id        *int                    `json:"id,omitempty"`
	Labels    *[]LableResonse         `json:"labels,omitempty"`
	Name      *string                 `json:"name,omitempty"`
	Ram       *float32                `json:"ram,omitempty"`
}

// CreateClusterNodeFields defines model for CreateClusterNodeFields.
type CreateClusterNodeFields struct {
	Count     *int                         `json:"count,omitempty"`
	NodeGroup *string                      `json:"node_group,omitempty"`
	Role      *CreateClusterNodeFieldsRole `json:"role,omitempty"`
}

// CreateClusterNodeFieldsRole defines model for CreateClusterNodeFields.Role.
type CreateClusterNodeFieldsRole string

// CreateClusterNodeGroupPayload defines model for Create_ClusterNodeGroup_payload.
type CreateClusterNodeGroupPayload struct {
	Count      *int   `json:"count,omitempty"`
	FlavorName string `json:"flavor_name"`
	Name       string `json:"name"`
}

// CreateClusterPayload defines model for Create_Cluster_Payload.
type CreateClusterPayload struct {
	DeploymentMode    *CreateClusterPayloadDeploymentMode `json:"deployment_mode,omitempty"`
	EnvironmentName   string                              `json:"environment_name"`
	KeypairName       string                              `json:"keypair_name"`
	KubernetesVersion string                              `json:"kubernetes_version"`
	MasterCount       *int                                `json:"master_count,omitempty"`
	MasterFlavorName  string                              `json:"master_flavor_name"`
	Name              string                              `json:"name"`
	NodeCount         *int                                `json:"node_count,omitempty"`
	NodeFlavorName    *string                             `json:"node_flavor_name,omitempty"`
	NodeGroups        *[]CreateClusterNodeGroupPayload    `json:"node_groups,omitempty"`
}

// CreateClusterPayloadDeploymentMode defines model for CreateClusterPayload.DeploymentMode.
type CreateClusterPayloadDeploymentMode string

// ErrorResponseModel defines model for ErrorResponseModel.
type ErrorResponseModel struct {
	ErrorReason *string `json:"error_reason,omitempty"`
	Message     *string `json:"message,omitempty"`
	Status      *bool   `json:"status,omitempty"`
}

// LableResonse defines model for LableResonse.
type LableResonse struct {
	Id    *int    `json:"id,omitempty"`
	Label *string `json:"label,omitempty"`
}

// MasterFlavorsResponse defines model for MasterFlavorsResponse.
type MasterFlavorsResponse struct {
	Flavors *[]ClusterFlavorFields `json:"flavors,omitempty"`
	Message *string                `json:"message,omitempty"`
	Status  *bool                  `json:"status,omitempty"`
}

// NameAvailableModel defines model for NameAvailableModel.
type NameAvailableModel struct {
	Available *bool   `json:"available,omitempty"`
	Message   *string `json:"message,omitempty"`
	Name      *string `json:"name,omitempty"`
}

// ResponseModel defines model for ResponseModel.
type ResponseModel struct {
	Message *string `json:"message,omitempty"`
	Status  *bool   `json:"status,omitempty"`
}

// Image defines model for image.
type Image = map[string]interface{}

// Region defines model for region.
type Region = map[string]interface{}

// ListClustersParams defines parameters for ListClusters.
type ListClustersParams struct {
	Page        *int    `form:"page,omitempty" json:"page,omitempty"`
	PageSize    *int    `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	Environment *string `form:"environment,omitempty" json:"environment,omitempty"`
	Search      *string `form:"search,omitempty" json:"search,omitempty"`
}

// GetClusterVersionsParams defines parameters for GetClusterVersions.
type GetClusterVersionsParams struct {
	Region *string `form:"region,omitempty" json:"region,omitempty"`
}

// CreateClusterJSONRequestBody defines body for CreateCluster for application/json ContentType.
type CreateClusterJSONRequestBody = CreateClusterPayload

// CreateNodeGroupJSONRequestBody defines body for CreateNodeGroup for application/json ContentType.
type CreateNodeGroupJSONRequestBody = CreateClusterNodeGroupPayload

// CreateNodeJSONRequestBody defines body for CreateNode for application/json ContentType.
type CreateNodeJSONRequestBody = CreateClusterNodeFields

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListClusters request
	ListClusters(ctx context.Context, params *ListClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateClusterWithBody request with any body
	CreateClusterWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCluster(ctx context.Context, body CreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClusterMasterFlavors request
	GetClusterMasterFlavors(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FetchClusterNameAvailability request
	FetchClusterNameAvailability(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClusterVersions request
	GetClusterVersions(ctx context.Context, params *GetClusterVersionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListNodeGroups request
	ListNodeGroups(ctx context.Context, clusterId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNodeGroupWithBody request with any body
	CreateNodeGroupWithBody(ctx context.Context, clusterId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateNodeGroup(ctx context.Context, clusterId int, body CreateNodeGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteANodeGroup request
	DeleteANodeGroup(ctx context.Context, clusterId int, nodeGroupId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrieveANodeGroup request
	RetrieveANodeGroup(ctx context.Context, clusterId int, nodeGroupId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClusterNodes request
	GetClusterNodes(ctx context.Context, clusterId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNodeWithBody request with any body
	CreateNodeWithBody(ctx context.Context, clusterId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateNode(ctx context.Context, clusterId int, body CreateNodeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteClusterNode request
	DeleteClusterNode(ctx context.Context, clusterId int, nodeId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteACluster request
	DeleteACluster(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GettingClusterDetail request
	GettingClusterDetail(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListClusters(ctx context.Context, params *ListClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListClustersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClusterWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClusterRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCluster(ctx context.Context, body CreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClusterRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClusterMasterFlavors(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClusterMasterFlavorsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FetchClusterNameAvailability(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFetchClusterNameAvailabilityRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClusterVersions(ctx context.Context, params *GetClusterVersionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClusterVersionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListNodeGroups(ctx context.Context, clusterId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListNodeGroupsRequest(c.Server, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNodeGroupWithBody(ctx context.Context, clusterId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNodeGroupRequestWithBody(c.Server, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNodeGroup(ctx context.Context, clusterId int, body CreateNodeGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNodeGroupRequest(c.Server, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteANodeGroup(ctx context.Context, clusterId int, nodeGroupId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteANodeGroupRequest(c.Server, clusterId, nodeGroupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrieveANodeGroup(ctx context.Context, clusterId int, nodeGroupId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveANodeGroupRequest(c.Server, clusterId, nodeGroupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClusterNodes(ctx context.Context, clusterId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClusterNodesRequest(c.Server, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNodeWithBody(ctx context.Context, clusterId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNodeRequestWithBody(c.Server, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNode(ctx context.Context, clusterId int, body CreateNodeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNodeRequest(c.Server, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteClusterNode(ctx context.Context, clusterId int, nodeId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteClusterNodeRequest(c.Server, clusterId, nodeId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteACluster(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAClusterRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GettingClusterDetail(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGettingClusterDetailRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListClustersRequest generates requests for ListClusters
func NewListClustersRequest(server string, params *ListClustersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/clusters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Environment != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "environment", runtime.ParamLocationQuery, *params.Environment); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateClusterRequest calls the generic CreateCluster builder with application/json body
func NewCreateClusterRequest(server string, body CreateClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateClusterRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateClusterRequestWithBody generates requests for CreateCluster with any type of body
func NewCreateClusterRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/clusters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetClusterMasterFlavorsRequest generates requests for GetClusterMasterFlavors
func NewGetClusterMasterFlavorsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/clusters/master-flavors")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFetchClusterNameAvailabilityRequest generates requests for FetchClusterNameAvailability
func NewFetchClusterNameAvailabilityRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/clusters/name-availability/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClusterVersionsRequest generates requests for GetClusterVersions
func NewGetClusterVersionsRequest(server string, params *GetClusterVersionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/clusters/versions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Region != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "region", runtime.ParamLocationQuery, *params.Region); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListNodeGroupsRequest generates requests for ListNodeGroups
func NewListNodeGroupsRequest(server string, clusterId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster_id", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/clusters/%s/node-groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateNodeGroupRequest calls the generic CreateNodeGroup builder with application/json body
func NewCreateNodeGroupRequest(server string, clusterId int, body CreateNodeGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateNodeGroupRequestWithBody(server, clusterId, "application/json", bodyReader)
}

// NewCreateNodeGroupRequestWithBody generates requests for CreateNodeGroup with any type of body
func NewCreateNodeGroupRequestWithBody(server string, clusterId int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster_id", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/clusters/%s/node-groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteANodeGroupRequest generates requests for DeleteANodeGroup
func NewDeleteANodeGroupRequest(server string, clusterId int, nodeGroupId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster_id", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "node_group_id", runtime.ParamLocationPath, nodeGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/clusters/%s/node-groups/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRetrieveANodeGroupRequest generates requests for RetrieveANodeGroup
func NewRetrieveANodeGroupRequest(server string, clusterId int, nodeGroupId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster_id", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "node_group_id", runtime.ParamLocationPath, nodeGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/clusters/%s/node-groups/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClusterNodesRequest generates requests for GetClusterNodes
func NewGetClusterNodesRequest(server string, clusterId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster_id", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/clusters/%s/nodes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateNodeRequest calls the generic CreateNode builder with application/json body
func NewCreateNodeRequest(server string, clusterId int, body CreateNodeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateNodeRequestWithBody(server, clusterId, "application/json", bodyReader)
}

// NewCreateNodeRequestWithBody generates requests for CreateNode with any type of body
func NewCreateNodeRequestWithBody(server string, clusterId int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster_id", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/clusters/%s/nodes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteClusterNodeRequest generates requests for DeleteClusterNode
func NewDeleteClusterNodeRequest(server string, clusterId int, nodeId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster_id", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "node_id", runtime.ParamLocationPath, nodeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/clusters/%s/nodes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteAClusterRequest generates requests for DeleteACluster
func NewDeleteAClusterRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/clusters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGettingClusterDetailRequest generates requests for GettingClusterDetail
func NewGettingClusterDetailRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/clusters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListClustersWithResponse request
	ListClustersWithResponse(ctx context.Context, params *ListClustersParams, reqEditors ...RequestEditorFn) (*ListClustersResponse, error)

	// CreateClusterWithBodyWithResponse request with any body
	CreateClusterWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error)

	CreateClusterWithResponse(ctx context.Context, body CreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error)

	// GetClusterMasterFlavorsWithResponse request
	GetClusterMasterFlavorsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetClusterMasterFlavorsResponse, error)

	// FetchClusterNameAvailabilityWithResponse request
	FetchClusterNameAvailabilityWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*FetchClusterNameAvailabilityResponse, error)

	// GetClusterVersionsWithResponse request
	GetClusterVersionsWithResponse(ctx context.Context, params *GetClusterVersionsParams, reqEditors ...RequestEditorFn) (*GetClusterVersionsResponse, error)

	// ListNodeGroupsWithResponse request
	ListNodeGroupsWithResponse(ctx context.Context, clusterId int, reqEditors ...RequestEditorFn) (*ListNodeGroupsResponse, error)

	// CreateNodeGroupWithBodyWithResponse request with any body
	CreateNodeGroupWithBodyWithResponse(ctx context.Context, clusterId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNodeGroupResponse, error)

	CreateNodeGroupWithResponse(ctx context.Context, clusterId int, body CreateNodeGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNodeGroupResponse, error)

	// DeleteANodeGroupWithResponse request
	DeleteANodeGroupWithResponse(ctx context.Context, clusterId int, nodeGroupId int, reqEditors ...RequestEditorFn) (*DeleteANodeGroupResponse, error)

	// RetrieveANodeGroupWithResponse request
	RetrieveANodeGroupWithResponse(ctx context.Context, clusterId int, nodeGroupId int, reqEditors ...RequestEditorFn) (*RetrieveANodeGroupResponse, error)

	// GetClusterNodesWithResponse request
	GetClusterNodesWithResponse(ctx context.Context, clusterId int, reqEditors ...RequestEditorFn) (*GetClusterNodesResponse, error)

	// CreateNodeWithBodyWithResponse request with any body
	CreateNodeWithBodyWithResponse(ctx context.Context, clusterId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNodeResponse, error)

	CreateNodeWithResponse(ctx context.Context, clusterId int, body CreateNodeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNodeResponse, error)

	// DeleteClusterNodeWithResponse request
	DeleteClusterNodeWithResponse(ctx context.Context, clusterId int, nodeId int, reqEditors ...RequestEditorFn) (*DeleteClusterNodeResponse, error)

	// DeleteAClusterWithResponse request
	DeleteAClusterWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteAClusterResponse, error)

	// GettingClusterDetailWithResponse request
	GettingClusterDetailWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GettingClusterDetailResponse, error)
}

type ListClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClusterListResponse
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r ListClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ClusterResponse
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
	JSON409      *ErrorResponseModel
	JSON422      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r CreateClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClusterMasterFlavorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MasterFlavorsResponse
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r GetClusterMasterFlavorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClusterMasterFlavorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FetchClusterNameAvailabilityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NameAvailableModel
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r FetchClusterNameAvailabilityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchClusterNameAvailabilityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClusterVersionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClusterVersions
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r GetClusterVersionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClusterVersionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListNodeGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClusterNodeGroupsListResponse
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r ListNodeGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListNodeGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNodeGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ClusterNodeGroupsCreateResponse
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
	JSON409      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r CreateNodeGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNodeGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteANodeGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseModel
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
	JSON409      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r DeleteANodeGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteANodeGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrieveANodeGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClusterNodeGroupsGetResponse
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r RetrieveANodeGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveANodeGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClusterNodesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClusterNodesListResponse
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r GetClusterNodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClusterNodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ClusterNodesListResponse
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
	JSON409      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r CreateNodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteClusterNodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseModel
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r DeleteClusterNodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteClusterNodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseModel
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r DeleteAClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GettingClusterDetailResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClusterResponse
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r GettingClusterDetailResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GettingClusterDetailResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListClustersWithResponse request returning *ListClustersResponse
func (c *ClientWithResponses) ListClustersWithResponse(ctx context.Context, params *ListClustersParams, reqEditors ...RequestEditorFn) (*ListClustersResponse, error) {
	rsp, err := c.ListClusters(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListClustersResponse(rsp)
}

// CreateClusterWithBodyWithResponse request with arbitrary body returning *CreateClusterResponse
func (c *ClientWithResponses) CreateClusterWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error) {
	rsp, err := c.CreateClusterWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClusterResponse(rsp)
}

func (c *ClientWithResponses) CreateClusterWithResponse(ctx context.Context, body CreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error) {
	rsp, err := c.CreateCluster(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClusterResponse(rsp)
}

// GetClusterMasterFlavorsWithResponse request returning *GetClusterMasterFlavorsResponse
func (c *ClientWithResponses) GetClusterMasterFlavorsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetClusterMasterFlavorsResponse, error) {
	rsp, err := c.GetClusterMasterFlavors(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClusterMasterFlavorsResponse(rsp)
}

// FetchClusterNameAvailabilityWithResponse request returning *FetchClusterNameAvailabilityResponse
func (c *ClientWithResponses) FetchClusterNameAvailabilityWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*FetchClusterNameAvailabilityResponse, error) {
	rsp, err := c.FetchClusterNameAvailability(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFetchClusterNameAvailabilityResponse(rsp)
}

// GetClusterVersionsWithResponse request returning *GetClusterVersionsResponse
func (c *ClientWithResponses) GetClusterVersionsWithResponse(ctx context.Context, params *GetClusterVersionsParams, reqEditors ...RequestEditorFn) (*GetClusterVersionsResponse, error) {
	rsp, err := c.GetClusterVersions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClusterVersionsResponse(rsp)
}

// ListNodeGroupsWithResponse request returning *ListNodeGroupsResponse
func (c *ClientWithResponses) ListNodeGroupsWithResponse(ctx context.Context, clusterId int, reqEditors ...RequestEditorFn) (*ListNodeGroupsResponse, error) {
	rsp, err := c.ListNodeGroups(ctx, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListNodeGroupsResponse(rsp)
}

// CreateNodeGroupWithBodyWithResponse request with arbitrary body returning *CreateNodeGroupResponse
func (c *ClientWithResponses) CreateNodeGroupWithBodyWithResponse(ctx context.Context, clusterId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNodeGroupResponse, error) {
	rsp, err := c.CreateNodeGroupWithBody(ctx, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNodeGroupResponse(rsp)
}

func (c *ClientWithResponses) CreateNodeGroupWithResponse(ctx context.Context, clusterId int, body CreateNodeGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNodeGroupResponse, error) {
	rsp, err := c.CreateNodeGroup(ctx, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNodeGroupResponse(rsp)
}

// DeleteANodeGroupWithResponse request returning *DeleteANodeGroupResponse
func (c *ClientWithResponses) DeleteANodeGroupWithResponse(ctx context.Context, clusterId int, nodeGroupId int, reqEditors ...RequestEditorFn) (*DeleteANodeGroupResponse, error) {
	rsp, err := c.DeleteANodeGroup(ctx, clusterId, nodeGroupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteANodeGroupResponse(rsp)
}

// RetrieveANodeGroupWithResponse request returning *RetrieveANodeGroupResponse
func (c *ClientWithResponses) RetrieveANodeGroupWithResponse(ctx context.Context, clusterId int, nodeGroupId int, reqEditors ...RequestEditorFn) (*RetrieveANodeGroupResponse, error) {
	rsp, err := c.RetrieveANodeGroup(ctx, clusterId, nodeGroupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveANodeGroupResponse(rsp)
}

// GetClusterNodesWithResponse request returning *GetClusterNodesResponse
func (c *ClientWithResponses) GetClusterNodesWithResponse(ctx context.Context, clusterId int, reqEditors ...RequestEditorFn) (*GetClusterNodesResponse, error) {
	rsp, err := c.GetClusterNodes(ctx, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClusterNodesResponse(rsp)
}

// CreateNodeWithBodyWithResponse request with arbitrary body returning *CreateNodeResponse
func (c *ClientWithResponses) CreateNodeWithBodyWithResponse(ctx context.Context, clusterId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNodeResponse, error) {
	rsp, err := c.CreateNodeWithBody(ctx, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNodeResponse(rsp)
}

func (c *ClientWithResponses) CreateNodeWithResponse(ctx context.Context, clusterId int, body CreateNodeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNodeResponse, error) {
	rsp, err := c.CreateNode(ctx, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNodeResponse(rsp)
}

// DeleteClusterNodeWithResponse request returning *DeleteClusterNodeResponse
func (c *ClientWithResponses) DeleteClusterNodeWithResponse(ctx context.Context, clusterId int, nodeId int, reqEditors ...RequestEditorFn) (*DeleteClusterNodeResponse, error) {
	rsp, err := c.DeleteClusterNode(ctx, clusterId, nodeId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteClusterNodeResponse(rsp)
}

// DeleteAClusterWithResponse request returning *DeleteAClusterResponse
func (c *ClientWithResponses) DeleteAClusterWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteAClusterResponse, error) {
	rsp, err := c.DeleteACluster(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAClusterResponse(rsp)
}

// GettingClusterDetailWithResponse request returning *GettingClusterDetailResponse
func (c *ClientWithResponses) GettingClusterDetailWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GettingClusterDetailResponse, error) {
	rsp, err := c.GettingClusterDetail(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGettingClusterDetailResponse(rsp)
}

// ParseListClustersResponse parses an HTTP response from a ListClustersWithResponse call
func ParseListClustersResponse(rsp *http.Response) (*ListClustersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClusterListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateClusterResponse parses an HTTP response from a CreateClusterWithResponse call
func ParseCreateClusterResponse(rsp *http.Response) (*CreateClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ClusterResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetClusterMasterFlavorsResponse parses an HTTP response from a GetClusterMasterFlavorsWithResponse call
func ParseGetClusterMasterFlavorsResponse(rsp *http.Response) (*GetClusterMasterFlavorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClusterMasterFlavorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MasterFlavorsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFetchClusterNameAvailabilityResponse parses an HTTP response from a FetchClusterNameAvailabilityWithResponse call
func ParseFetchClusterNameAvailabilityResponse(rsp *http.Response) (*FetchClusterNameAvailabilityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FetchClusterNameAvailabilityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NameAvailableModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetClusterVersionsResponse parses an HTTP response from a GetClusterVersionsWithResponse call
func ParseGetClusterVersionsResponse(rsp *http.Response) (*GetClusterVersionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClusterVersionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClusterVersions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseListNodeGroupsResponse parses an HTTP response from a ListNodeGroupsWithResponse call
func ParseListNodeGroupsResponse(rsp *http.Response) (*ListNodeGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListNodeGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClusterNodeGroupsListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateNodeGroupResponse parses an HTTP response from a CreateNodeGroupWithResponse call
func ParseCreateNodeGroupResponse(rsp *http.Response) (*CreateNodeGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNodeGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ClusterNodeGroupsCreateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseDeleteANodeGroupResponse parses an HTTP response from a DeleteANodeGroupWithResponse call
func ParseDeleteANodeGroupResponse(rsp *http.Response) (*DeleteANodeGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteANodeGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseRetrieveANodeGroupResponse parses an HTTP response from a RetrieveANodeGroupWithResponse call
func ParseRetrieveANodeGroupResponse(rsp *http.Response) (*RetrieveANodeGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveANodeGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClusterNodeGroupsGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetClusterNodesResponse parses an HTTP response from a GetClusterNodesWithResponse call
func ParseGetClusterNodesResponse(rsp *http.Response) (*GetClusterNodesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClusterNodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClusterNodesListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateNodeResponse parses an HTTP response from a CreateNodeWithResponse call
func ParseCreateNodeResponse(rsp *http.Response) (*CreateNodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ClusterNodesListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseDeleteClusterNodeResponse parses an HTTP response from a DeleteClusterNodeWithResponse call
func ParseDeleteClusterNodeResponse(rsp *http.Response) (*DeleteClusterNodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteClusterNodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteAClusterResponse parses an HTTP response from a DeleteAClusterWithResponse call
func ParseDeleteAClusterResponse(rsp *http.Response) (*DeleteAClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGettingClusterDetailResponse parses an HTTP response from a GettingClusterDetailWithResponse call
func ParseGettingClusterDetailResponse(rsp *http.Response) (*GettingClusterDetailResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GettingClusterDetailResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClusterResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}
