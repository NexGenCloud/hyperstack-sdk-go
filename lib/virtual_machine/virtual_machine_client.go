// Package virtual_machine provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package virtual_machine

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"github.com/NexGenCloud/hyperstack-sdk-go/lib/time"

	"github.com/oapi-codegen/runtime"
)

// Defines values for CreateSecurityRulePayloadProtocol.
const (
	Ah        CreateSecurityRulePayloadProtocol = "ah"
	Any       CreateSecurityRulePayloadProtocol = "any"
	Dccp      CreateSecurityRulePayloadProtocol = "dccp"
	Egp       CreateSecurityRulePayloadProtocol = "egp"
	Esp       CreateSecurityRulePayloadProtocol = "esp"
	Gre       CreateSecurityRulePayloadProtocol = "gre"
	Hopopt    CreateSecurityRulePayloadProtocol = "hopopt"
	Icmp      CreateSecurityRulePayloadProtocol = "icmp"
	Icmpv6    CreateSecurityRulePayloadProtocol = "icmpv6"
	Igmp      CreateSecurityRulePayloadProtocol = "igmp"
	Ip        CreateSecurityRulePayloadProtocol = "ip"
	Ipip      CreateSecurityRulePayloadProtocol = "ipip"
	Ipv6Encap CreateSecurityRulePayloadProtocol = "ipv6-encap"
	Ipv6Frag  CreateSecurityRulePayloadProtocol = "ipv6-frag"
	Ipv6Icmp  CreateSecurityRulePayloadProtocol = "ipv6-icmp"
	Ipv6Nonxt CreateSecurityRulePayloadProtocol = "ipv6-nonxt"
	Ipv6Opts  CreateSecurityRulePayloadProtocol = "ipv6-opts"
	Ipv6Route CreateSecurityRulePayloadProtocol = "ipv6-route"
	Ospf      CreateSecurityRulePayloadProtocol = "ospf"
	Pgm       CreateSecurityRulePayloadProtocol = "pgm"
	Rsvp      CreateSecurityRulePayloadProtocol = "rsvp"
	Sctp      CreateSecurityRulePayloadProtocol = "sctp"
	Tcp       CreateSecurityRulePayloadProtocol = "tcp"
	Udp       CreateSecurityRulePayloadProtocol = "udp"
	Udplite   CreateSecurityRulePayloadProtocol = "udplite"
	Vrrp      CreateSecurityRulePayloadProtocol = "vrrp"
)

// Defines values for EnvironmentFeaturesGreenStatus.
const (
	GREEN          EnvironmentFeaturesGreenStatus = "GREEN"
	NOTGREEN       EnvironmentFeaturesGreenStatus = "NOT_GREEN"
	PARTIALLYGREEN EnvironmentFeaturesGreenStatus = "PARTIALLY_GREEN"
)

// AttachFirewallsToVMPayload defines model for AttachFirewallsToVMPayload.
type AttachFirewallsToVMPayload struct {
	// Firewalls Ids of the firewalls to be attached with a virtual machine.
	Firewalls []int `json:"firewalls"`
}

// ContractInstanceFields defines model for ContractInstanceFields.
type ContractInstanceFields struct {
	CreatedAt       *time.CustomTime `json:"created_at,omitempty"`
	FlavorName      *string    `json:"flavor_name,omitempty"`
	GpuCount        *int       `json:"gpu_count,omitempty"`
	Id              *int       `json:"id,omitempty"`
	Name            *string    `json:"name,omitempty"`
	Status          *string    `json:"status,omitempty"`
	TerminationTime *time.CustomTime `json:"termination_time,omitempty"`
	TotalUsageTime  *int       `json:"total_usage_time,omitempty"`
}

// ContractInstancesResponse defines model for ContractInstancesResponse.
type ContractInstancesResponse struct {
	Instances *[]ContractInstanceFields `json:"instances,omitempty"`
	Message   *string                   `json:"message,omitempty"`
	Status    *bool                     `json:"status,omitempty"`
}

// CreateInstancesPayload defines model for CreateInstancesPayload.
type CreateInstancesPayload struct {
	// AssignFloatingIp When this field is set to `true`, it attaches a [public IP address](https://infrahub-doc.nexgencloud.com/docs/virtual-machines/public-ip)to the virtual machine, enabling internet accessibility.
	AssignFloatingIp *bool `json:"assign_floating_ip,omitempty"`

	// CallbackUrl An optional URL where actions performed on the virtual machine will be sent. For additional information on event callbacks, [**click here**](https://infrahub-doc.nexgencloud.com/docs/features/webhooks-callbacks).
	CallbackUrl *string `json:"callback_url,omitempty"`

	// Count The number of virtual machines to be created.
	Count int `json:"count"`

	// CreateBootableVolume Indicates whether to create a bootable volume for the virtual machine. When set to `true`, a bootable volume will be created; the default value is `false`.
	CreateBootableVolume *bool `json:"create_bootable_volume,omitempty"`

	// EnablePortRandomization Indicates whether to enable port randomization.This setting is only effective if 'assign_floating_ip' is true. Defaults to true.
	EnablePortRandomization *bool `json:"enable_port_randomization,omitempty"`

	// EnvironmentName The name of the [environment](https://infrahub-doc.nexgencloud.com/docs/features/environments-available-features) in which the virtual machine is to be created.
	EnvironmentName string              `json:"environment_name"`
	Flavor          *FlavorObjectFields `json:"flavor,omitempty"`

	// FlavorName The name of the GPU hardware configuration ([flavor](https://infrahub-doc.nexgencloud.com/docs/hardware/flavors)) for the virtual machines being created.
	FlavorName string `json:"flavor_name"`

	// ImageName The [operating system (OS) image](https://infrahub-doc.nexgencloud.com/docs/virtual-machines/images) name designated for installation on the virtual machine.It also accepts custom, private images, created from [existing snapshots](https://infrahub-doc.nexgencloud.com/docs/virtual-machines/custom-images).
	ImageName *string `json:"image_name,omitempty"`

	// KeyName The name of the existing SSH key pair to be used for secure access to the virtual machine. For additional information on SSH key pairs, [**click here**](https://infrahub-doc.nexgencloud.com/docs/getting-started/create-keypair).
	KeyName string    `json:"key_name"`
	Labels  *[]string `json:"labels,omitempty"`

	// Name The name of the virtual machine being created.
	Name          string                       `json:"name"`
	Profile       *ProfileObjectFields         `json:"profile,omitempty"`
	SecurityRules *[]CreateSecurityRulePayload `json:"security_rules,omitempty"`

	// UserData Optional initialization configuration commands to manage the configuration of a virtual machine at launch using cloud-init scripts. For more information about custom VM configuration using cloud-init, [**click here**](https://infrahub-doc.nexgencloud.com/docs/virtual-machines/initialization-configuration).
	UserData *string `json:"user_data,omitempty"`

	// VolumeName The names of the volume(s) to be attached to the virtual machine being created.
	VolumeName *string `json:"volume_name,omitempty"`
}

// CreateInstancesResponse defines model for CreateInstancesResponse.
type CreateInstancesResponse struct {
	Instances *[]InstanceFields `json:"instances,omitempty"`
	Message   *string           `json:"message,omitempty"`
	Status    *bool             `json:"status,omitempty"`
}

// CreateSecurityRulePayload defines model for CreateSecurityRulePayload.
type CreateSecurityRulePayload struct {
	// Direction The direction of traffic that the firewall rule applies to.
	Direction string `json:"direction"`

	// Ethertype The Ethernet type associated with the rule.
	Ethertype    string `json:"ethertype"`
	PortRangeMax *int   `json:"port_range_max,omitempty"`
	PortRangeMin *int   `json:"port_range_min,omitempty"`

	// Protocol The network protocol associated with the rule. Call the [`GET /core/sg-rules-protocols`](https://infrahub-api-doc.nexgencloud.com/#get-/core/sg-rules-protocols) endpoint to retrieve a list of permitted network protocols.
	Protocol CreateSecurityRulePayloadProtocol `json:"protocol"`

	// RemoteIpPrefix The IP address range that is allowed to access the specified port. Use "0.0.0.0/0" to allow any IP address.
	RemoteIpPrefix string `json:"remote_ip_prefix"`
}

// CreateSecurityRulePayloadProtocol The network protocol associated with the rule. Call the [`GET /core/sg-rules-protocols`](https://infrahub-api-doc.nexgencloud.com/#get-/core/sg-rules-protocols) endpoint to retrieve a list of permitted network protocols.
type CreateSecurityRulePayloadProtocol string

// CreateSnapshotPayload defines model for CreateSnapshotPayload.
type CreateSnapshotPayload struct {
	// Description description
	Description string `json:"description"`

	// IsImage Indicates if the snapshot is an image
	IsImage bool `json:"is_image"`

	// Labels Labels associated with snapshot
	Labels *[]string `json:"labels,omitempty"`

	// Name Snapshot name
	Name string `json:"name"`
}

// CreateSnapshotResponse defines model for CreateSnapshotResponse.
type CreateSnapshotResponse struct {
	Message  *string         `json:"message,omitempty"`
	Snapshot *SnapshotFields `json:"snapshot,omitempty"`
	Status   *bool           `json:"status,omitempty"`
}

// EditlabelofanexistingVMPayload defines model for EditlabelofanexistingVMPayload.
type EditlabelofanexistingVMPayload struct {
	// Labels Multiple labels can be added by separating with spaces
	Labels *[]string `json:"labels,omitempty"`
}

// EnvironmentFeatures defines model for EnvironmentFeatures.
type EnvironmentFeatures struct {
	GreenStatus      *EnvironmentFeaturesGreenStatus `json:"green_status,omitempty"`
	NetworkOptimised *bool                           `json:"network_optimised,omitempty"`
}

// EnvironmentFeaturesGreenStatus defines model for EnvironmentFeatures.GreenStatus.
type EnvironmentFeaturesGreenStatus string

// ErrorResponseModel defines model for ErrorResponseModel.
type ErrorResponseModel struct {
	ErrorReason *string `json:"error_reason,omitempty"`
	Message     *string `json:"message,omitempty"`
	Status      *bool   `json:"status,omitempty"`
}

// FlavorLabelFields defines model for FlavorLabelFields.
type FlavorLabelFields struct {
	Id    *int    `json:"id,omitempty"`
	Label *string `json:"label,omitempty"`
}

// FlavorObjectFields defines model for FlavorObjectFields.
type FlavorObjectFields struct {
	Cpu      *int     `json:"cpu,omitempty"`
	Disk     *int     `json:"disk,omitempty"`
	Gpu      *string  `json:"gpu,omitempty"`
	GpuCount *int     `json:"gpu_count,omitempty"`
	Ram      *float32 `json:"ram,omitempty"`
}

// Instance defines model for Instance.
type Instance struct {
	Instance *InstanceFields `json:"instance,omitempty"`
	Message  *string         `json:"message,omitempty"`
	Status   *bool           `json:"status,omitempty"`
}

// InstanceEnvironmentFields defines model for InstanceEnvironmentFields.
type InstanceEnvironmentFields struct {
	Features *EnvironmentFeatures `json:"features,omitempty"`
	Id       *int                 `json:"id,omitempty"`
	Name     *string              `json:"name,omitempty"`
	OrgId    *int                 `json:"org_id,omitempty"`
	Region   *string              `json:"region,omitempty"`
}

// InstanceFields defines model for InstanceFields.
type InstanceFields struct {
	CallbackUrl             *string                           `json:"callback_url,omitempty"`
	ContractId              *int                              `json:"contract_id,omitempty"`
	CreatedAt               *time.CustomTime                        `json:"created_at,omitempty"`
	Environment             *InstanceEnvironmentFields        `json:"environment,omitempty"`
	Features                *map[string]interface{}           `json:"features,omitempty"`
	FixedIp                 *string                           `json:"fixed_ip,omitempty"`
	Flavor                  *InstanceFlavorFields             `json:"flavor,omitempty"`
	FloatingIp              *string                           `json:"floating_ip,omitempty"`
	FloatingIpStatus        *string                           `json:"floating_ip_status,omitempty"`
	Id                      *int                              `json:"id,omitempty"`
	Image                   *InstanceImageFields              `json:"image,omitempty"`
	Keypair                 *InstanceKeypairFields            `json:"keypair,omitempty"`
	Labels                  *[]string                         `json:"labels,omitempty"`
	Locked                  *bool                             `json:"locked,omitempty"`
	Name                    *string                           `json:"name,omitempty"`
	Os                      *string                           `json:"os,omitempty"`
	PortRandomization       *bool                             `json:"port_randomization,omitempty"`
	PortRandomizationStatus *string                           `json:"port_randomization_status,omitempty"`
	PowerState              *string                           `json:"power_state,omitempty"`
	RequiresPublicIp        *bool                             `json:"requires_public_ip,omitempty"`
	SecurityRules           *[]SecurityRulesFieldsforInstance `json:"security_rules,omitempty"`
	Status                  *string                           `json:"status,omitempty"`
	VmState                 *string                           `json:"vm_state,omitempty"`
	VolumeAttachments       *[]VolumeAttachmentFields         `json:"volume_attachments,omitempty"`
}

// InstanceFlavorFields defines model for InstanceFlavorFields.
type InstanceFlavorFields struct {
	Cpu       *int                    `json:"cpu,omitempty"`
	Disk      *int                    `json:"disk,omitempty"`
	Ephemeral *int                    `json:"ephemeral,omitempty"`
	Features  *map[string]interface{} `json:"features,omitempty"`
	Gpu       *string                 `json:"gpu,omitempty"`
	GpuCount  *int                    `json:"gpu_count,omitempty"`
	Id        *int                    `json:"id,omitempty"`
	Labels    *[]FlavorLabelFields    `json:"labels,omitempty"`
	Name      *string                 `json:"name,omitempty"`
	Ram       *float32                `json:"ram,omitempty"`
}

// InstanceImageFields defines model for InstanceImageFields.
type InstanceImageFields struct {
	Name *string `json:"name,omitempty"`
}

// InstanceKeypairFields defines model for InstanceKeypairFields.
type InstanceKeypairFields struct {
	Name *string `json:"name,omitempty"`
}

// InstanceResizePayload defines model for InstanceResizePayload.
type InstanceResizePayload struct {
	Flavor     *FlavorObjectFields `json:"flavor,omitempty"`
	FlavorName *string             `json:"flavor_name,omitempty"`
}

// Instances defines model for Instances.
type Instances struct {
	Count     *int              `json:"count,omitempty"`
	Instances *[]InstanceFields `json:"instances,omitempty"`
	Message   *string           `json:"message,omitempty"`
	Page      *int              `json:"page,omitempty"`
	PageSize  *int              `json:"page_size,omitempty"`
	Status    *bool             `json:"status,omitempty"`
}

// MetricItemFields defines model for MetricItemFields.
type MetricItemFields struct {
	Columns *[]string                   `json:"columns,omitempty"`
	Data    *[][]map[string]interface{} `json:"data,omitempty"`
	Unit    *string                     `json:"unit,omitempty"`
}

// MetricsFields defines model for MetricsFields.
type MetricsFields struct {
	Cpu          *MetricItemFields `json:"cpu,omitempty"`
	DiskRead     *MetricItemFields `json:"disk.read,omitempty"`
	DiskWrite    *MetricItemFields `json:"disk.write,omitempty"`
	MemoryUsages *MetricItemFields `json:"memory.usages,omitempty"`
	NetworkIn    *MetricItemFields `json:"network.in,omitempty"`
	NetworkOut   *MetricItemFields `json:"network.out,omitempty"`
}

// NameAvailableModel defines model for NameAvailableModel.
type NameAvailableModel struct {
	Available *bool   `json:"available,omitempty"`
	Message   *string `json:"message,omitempty"`
	Name      *string `json:"name,omitempty"`
}

// ProfileObjectFields defines model for ProfileObjectFields.
type ProfileObjectFields struct {
	Description *string `json:"description,omitempty"`
	Name        string  `json:"name"`
}

// ResponseModel defines model for ResponseModel.
type ResponseModel struct {
	Message *string `json:"message,omitempty"`
	Status  *bool   `json:"status,omitempty"`
}

// SecurityGroupRule defines model for SecurityGroupRule.
type SecurityGroupRule struct {
	Message      *string                  `json:"message,omitempty"`
	SecurityRule *SecurityGroupRuleFields `json:"security_rule,omitempty"`
	Status       *bool                    `json:"status,omitempty"`
}

// SecurityGroupRuleFields defines model for SecurityGroupRuleFields.
type SecurityGroupRuleFields struct {
	CreatedAt      *time.CustomTime `json:"created_at,omitempty"`
	Direction      *string    `json:"direction,omitempty"`
	Ethertype      *string    `json:"ethertype,omitempty"`
	Id             *int       `json:"id,omitempty"`
	PortRangeMax   *int       `json:"port_range_max,omitempty"`
	PortRangeMin   *int       `json:"port_range_min,omitempty"`
	Protocol       *string    `json:"protocol,omitempty"`
	RemoteIpPrefix *string    `json:"remote_ip_prefix,omitempty"`
	Status         *string    `json:"status,omitempty"`
}

// SecurityRulesFieldsforInstance defines model for SecurityRulesFieldsforInstance.
type SecurityRulesFieldsforInstance struct {
	CreatedAt      *time.CustomTime `json:"created_at,omitempty"`
	Direction      *string    `json:"direction,omitempty"`
	Ethertype      *string    `json:"ethertype,omitempty"`
	Id             *int       `json:"id,omitempty"`
	PortRangeMax   *int       `json:"port_range_max,omitempty"`
	PortRangeMin   *int       `json:"port_range_min,omitempty"`
	Protocol       *string    `json:"protocol,omitempty"`
	RemoteIpPrefix *string    `json:"remote_ip_prefix,omitempty"`
	Status         *string    `json:"status,omitempty"`
}

// SnapshotFields defines model for SnapshotFields.
type SnapshotFields struct {
	// CreatedAt Creation timestamp
	CreatedAt time.CustomTime `json:"created_at"`

	// Description Description of the snapshot
	Description string `json:"description"`

	// HasFloatingIp Indicates if the VM had a floating IP assigned
	HasFloatingIp *bool `json:"has_floating_ip,omitempty"`

	// Id Snapshot ID
	Id int `json:"id"`

	// IsImage Indicates if the snapshot is an image
	IsImage bool `json:"is_image"`

	// Labels Labels associated with snapshot
	Labels *[]string `json:"labels,omitempty"`

	// Name Snapshot name
	Name string `json:"name"`

	// RegionId Region where the snapshot will be available
	RegionId int `json:"region_id"`

	// Size Size in GB of the snapshot
	Size int `json:"size"`

	// Status Status of the snapshot
	Status string `json:"status"`

	// UpdatedAt Last update timestamp
	UpdatedAt time.CustomTime `json:"updated_at"`

	// VmId ID of the VM from which the snapshot is created
	VmId int `json:"vm_id"`
}

// VolumeAttachmentFields defines model for VolumeAttachmentFields.
type VolumeAttachmentFields struct {
	CreatedAt *time.CustomTime               `json:"created_at,omitempty"`
	Device    *string                  `json:"device,omitempty"`
	Status    *string                  `json:"status,omitempty"`
	Volume    *VolumeFieldsforInstance `json:"volume,omitempty"`
}

// VolumeFieldsforInstance defines model for VolumeFieldsforInstance.
type VolumeFieldsforInstance struct {
	Bootable    *bool   `json:"bootable,omitempty"`
	Description *string `json:"description,omitempty"`
	Id          *int    `json:"id,omitempty"`
	Name        *string `json:"name,omitempty"`
	Size        *int    `json:"size,omitempty"`
	VolumeType  *string `json:"volume_type,omitempty"`
}

// ListVirtualMachinesParams defines parameters for ListVirtualMachines.
type ListVirtualMachinesParams struct {
	Page        *string `form:"page,omitempty" json:"page,omitempty"`
	PageSize    *string `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	Search      *string `form:"search,omitempty" json:"search,omitempty"`
	Environment *string `form:"environment,omitempty" json:"environment,omitempty"`
}

// RetrieveVirtualMachinesAssociatedWithAContractParams defines parameters for RetrieveVirtualMachinesAssociatedWithAContract.
type RetrieveVirtualMachinesAssociatedWithAContractParams struct {
	Page     *string `form:"page,omitempty" json:"page,omitempty"`
	PageSize *string `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	Search   *string `form:"search,omitempty" json:"search,omitempty"`
}

// RetrieveVirtualMachinePerformanceMetricsParams defines parameters for RetrieveVirtualMachinePerformanceMetrics.
type RetrieveVirtualMachinePerformanceMetricsParams struct {
	Duration *string `form:"duration,omitempty" json:"duration,omitempty"`
}

// CreateVirtualMachinesJSONRequestBody defines body for CreateVirtualMachines for application/json ContentType.
type CreateVirtualMachinesJSONRequestBody = CreateInstancesPayload

// AddFirewallRuleToVirtualMachineJSONRequestBody defines body for AddFirewallRuleToVirtualMachine for application/json ContentType.
type AddFirewallRuleToVirtualMachineJSONRequestBody = CreateSecurityRulePayload

// AttachFirewallsToAVirtualMachineJSONRequestBody defines body for AttachFirewallsToAVirtualMachine for application/json ContentType.
type AttachFirewallsToAVirtualMachineJSONRequestBody = AttachFirewallsToVMPayload

// EditVirtualMachineLabelsJSONRequestBody defines body for EditVirtualMachineLabels for application/json ContentType.
type EditVirtualMachineLabelsJSONRequestBody = EditlabelofanexistingVMPayload

// ResizeVirtualMachineJSONRequestBody defines body for ResizeVirtualMachine for application/json ContentType.
type ResizeVirtualMachineJSONRequestBody = InstanceResizePayload

// CreateSnapshotFromAVirtualMachineJSONRequestBody defines body for CreateSnapshotFromAVirtualMachine for application/json ContentType.
type CreateSnapshotFromAVirtualMachineJSONRequestBody = CreateSnapshotPayload

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListVirtualMachines request
	ListVirtualMachines(ctx context.Context, params *ListVirtualMachinesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVirtualMachinesWithBody request with any body
	CreateVirtualMachinesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVirtualMachines(ctx context.Context, body CreateVirtualMachinesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrieveVirtualMachinesAssociatedWithAContract request
	RetrieveVirtualMachinesAssociatedWithAContract(ctx context.Context, contractId int, params *RetrieveVirtualMachinesAssociatedWithAContractParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FetchVirtualMachineNameAvailability request
	FetchVirtualMachineNameAvailability(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddFirewallRuleToVirtualMachineWithBody request with any body
	AddFirewallRuleToVirtualMachineWithBody(ctx context.Context, virtualMachineId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddFirewallRuleToVirtualMachine(ctx context.Context, virtualMachineId int, body AddFirewallRuleToVirtualMachineJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFirewallRuleFromVirtualMachine request
	DeleteFirewallRuleFromVirtualMachine(ctx context.Context, virtualMachineId int, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVirtualMachine request
	DeleteVirtualMachine(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrieveVirtualMachineDetails request
	RetrieveVirtualMachineDetails(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachFirewallsToAVirtualMachineWithBody request with any body
	AttachFirewallsToAVirtualMachineWithBody(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AttachFirewallsToAVirtualMachine(ctx context.Context, vmId int, body AttachFirewallsToAVirtualMachineJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HardRebootVirtualMachine request
	HardRebootVirtualMachine(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HibernateVirtualMachine request
	HibernateVirtualMachine(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RestoreVirtualMachineFromHibernation request
	RestoreVirtualMachineFromHibernation(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditVirtualMachineLabelsWithBody request with any body
	EditVirtualMachineLabelsWithBody(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditVirtualMachineLabels(ctx context.Context, vmId int, body EditVirtualMachineLabelsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrieveVirtualMachinePerformanceMetrics request
	RetrieveVirtualMachinePerformanceMetrics(ctx context.Context, vmId int, params *RetrieveVirtualMachinePerformanceMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResizeVirtualMachineWithBody request with any body
	ResizeVirtualMachineWithBody(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResizeVirtualMachine(ctx context.Context, vmId int, body ResizeVirtualMachineJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSnapshotFromAVirtualMachineWithBody request with any body
	CreateSnapshotFromAVirtualMachineWithBody(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSnapshotFromAVirtualMachine(ctx context.Context, vmId int, body CreateSnapshotFromAVirtualMachineJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartVirtualMachine request
	StartVirtualMachine(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StopVirtualMachine request
	StopVirtualMachine(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListVirtualMachines(ctx context.Context, params *ListVirtualMachinesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListVirtualMachinesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVirtualMachinesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVirtualMachinesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVirtualMachines(ctx context.Context, body CreateVirtualMachinesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVirtualMachinesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrieveVirtualMachinesAssociatedWithAContract(ctx context.Context, contractId int, params *RetrieveVirtualMachinesAssociatedWithAContractParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveVirtualMachinesAssociatedWithAContractRequest(c.Server, contractId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FetchVirtualMachineNameAvailability(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFetchVirtualMachineNameAvailabilityRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddFirewallRuleToVirtualMachineWithBody(ctx context.Context, virtualMachineId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddFirewallRuleToVirtualMachineRequestWithBody(c.Server, virtualMachineId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddFirewallRuleToVirtualMachine(ctx context.Context, virtualMachineId int, body AddFirewallRuleToVirtualMachineJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddFirewallRuleToVirtualMachineRequest(c.Server, virtualMachineId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFirewallRuleFromVirtualMachine(ctx context.Context, virtualMachineId int, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFirewallRuleFromVirtualMachineRequest(c.Server, virtualMachineId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVirtualMachine(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVirtualMachineRequest(c.Server, vmId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrieveVirtualMachineDetails(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveVirtualMachineDetailsRequest(c.Server, vmId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachFirewallsToAVirtualMachineWithBody(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachFirewallsToAVirtualMachineRequestWithBody(c.Server, vmId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachFirewallsToAVirtualMachine(ctx context.Context, vmId int, body AttachFirewallsToAVirtualMachineJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachFirewallsToAVirtualMachineRequest(c.Server, vmId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HardRebootVirtualMachine(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHardRebootVirtualMachineRequest(c.Server, vmId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HibernateVirtualMachine(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHibernateVirtualMachineRequest(c.Server, vmId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreVirtualMachineFromHibernation(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreVirtualMachineFromHibernationRequest(c.Server, vmId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditVirtualMachineLabelsWithBody(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditVirtualMachineLabelsRequestWithBody(c.Server, vmId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditVirtualMachineLabels(ctx context.Context, vmId int, body EditVirtualMachineLabelsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditVirtualMachineLabelsRequest(c.Server, vmId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrieveVirtualMachinePerformanceMetrics(ctx context.Context, vmId int, params *RetrieveVirtualMachinePerformanceMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveVirtualMachinePerformanceMetricsRequest(c.Server, vmId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResizeVirtualMachineWithBody(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResizeVirtualMachineRequestWithBody(c.Server, vmId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResizeVirtualMachine(ctx context.Context, vmId int, body ResizeVirtualMachineJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResizeVirtualMachineRequest(c.Server, vmId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSnapshotFromAVirtualMachineWithBody(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSnapshotFromAVirtualMachineRequestWithBody(c.Server, vmId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSnapshotFromAVirtualMachine(ctx context.Context, vmId int, body CreateSnapshotFromAVirtualMachineJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSnapshotFromAVirtualMachineRequest(c.Server, vmId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartVirtualMachine(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartVirtualMachineRequest(c.Server, vmId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StopVirtualMachine(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopVirtualMachineRequest(c.Server, vmId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListVirtualMachinesRequest generates requests for ListVirtualMachines
func NewListVirtualMachinesRequest(server string, params *ListVirtualMachinesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Environment != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "environment", runtime.ParamLocationQuery, *params.Environment); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVirtualMachinesRequest calls the generic CreateVirtualMachines builder with application/json body
func NewCreateVirtualMachinesRequest(server string, body CreateVirtualMachinesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVirtualMachinesRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateVirtualMachinesRequestWithBody generates requests for CreateVirtualMachines with any type of body
func NewCreateVirtualMachinesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRetrieveVirtualMachinesAssociatedWithAContractRequest generates requests for RetrieveVirtualMachinesAssociatedWithAContract
func NewRetrieveVirtualMachinesAssociatedWithAContractRequest(server string, contractId int, params *RetrieveVirtualMachinesAssociatedWithAContractParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "contract_id", runtime.ParamLocationPath, contractId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/contract/%s/virtual-machines", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFetchVirtualMachineNameAvailabilityRequest generates requests for FetchVirtualMachineNameAvailability
func NewFetchVirtualMachineNameAvailabilityRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/name-availability/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddFirewallRuleToVirtualMachineRequest calls the generic AddFirewallRuleToVirtualMachine builder with application/json body
func NewAddFirewallRuleToVirtualMachineRequest(server string, virtualMachineId int, body AddFirewallRuleToVirtualMachineJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddFirewallRuleToVirtualMachineRequestWithBody(server, virtualMachineId, "application/json", bodyReader)
}

// NewAddFirewallRuleToVirtualMachineRequestWithBody generates requests for AddFirewallRuleToVirtualMachine with any type of body
func NewAddFirewallRuleToVirtualMachineRequestWithBody(server string, virtualMachineId int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "virtual_machine_id", runtime.ParamLocationPath, virtualMachineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s/sg-rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFirewallRuleFromVirtualMachineRequest generates requests for DeleteFirewallRuleFromVirtualMachine
func NewDeleteFirewallRuleFromVirtualMachineRequest(server string, virtualMachineId int, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "virtual_machine_id", runtime.ParamLocationPath, virtualMachineId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s/sg-rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteVirtualMachineRequest generates requests for DeleteVirtualMachine
func NewDeleteVirtualMachineRequest(server string, vmId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vm_id", runtime.ParamLocationPath, vmId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRetrieveVirtualMachineDetailsRequest generates requests for RetrieveVirtualMachineDetails
func NewRetrieveVirtualMachineDetailsRequest(server string, vmId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vm_id", runtime.ParamLocationPath, vmId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAttachFirewallsToAVirtualMachineRequest calls the generic AttachFirewallsToAVirtualMachine builder with application/json body
func NewAttachFirewallsToAVirtualMachineRequest(server string, vmId int, body AttachFirewallsToAVirtualMachineJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAttachFirewallsToAVirtualMachineRequestWithBody(server, vmId, "application/json", bodyReader)
}

// NewAttachFirewallsToAVirtualMachineRequestWithBody generates requests for AttachFirewallsToAVirtualMachine with any type of body
func NewAttachFirewallsToAVirtualMachineRequestWithBody(server string, vmId int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vm_id", runtime.ParamLocationPath, vmId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s/attach-firewalls", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewHardRebootVirtualMachineRequest generates requests for HardRebootVirtualMachine
func NewHardRebootVirtualMachineRequest(server string, vmId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vm_id", runtime.ParamLocationPath, vmId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s/hard-reboot", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHibernateVirtualMachineRequest generates requests for HibernateVirtualMachine
func NewHibernateVirtualMachineRequest(server string, vmId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vm_id", runtime.ParamLocationPath, vmId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s/hibernate", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreVirtualMachineFromHibernationRequest generates requests for RestoreVirtualMachineFromHibernation
func NewRestoreVirtualMachineFromHibernationRequest(server string, vmId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vm_id", runtime.ParamLocationPath, vmId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s/hibernate-restore", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEditVirtualMachineLabelsRequest calls the generic EditVirtualMachineLabels builder with application/json body
func NewEditVirtualMachineLabelsRequest(server string, vmId int, body EditVirtualMachineLabelsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditVirtualMachineLabelsRequestWithBody(server, vmId, "application/json", bodyReader)
}

// NewEditVirtualMachineLabelsRequestWithBody generates requests for EditVirtualMachineLabels with any type of body
func NewEditVirtualMachineLabelsRequestWithBody(server string, vmId int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vm_id", runtime.ParamLocationPath, vmId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s/label", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRetrieveVirtualMachinePerformanceMetricsRequest generates requests for RetrieveVirtualMachinePerformanceMetrics
func NewRetrieveVirtualMachinePerformanceMetricsRequest(server string, vmId int, params *RetrieveVirtualMachinePerformanceMetricsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vm_id", runtime.ParamLocationPath, vmId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s/metrics", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Duration != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "duration", runtime.ParamLocationQuery, *params.Duration); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewResizeVirtualMachineRequest calls the generic ResizeVirtualMachine builder with application/json body
func NewResizeVirtualMachineRequest(server string, vmId int, body ResizeVirtualMachineJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResizeVirtualMachineRequestWithBody(server, vmId, "application/json", bodyReader)
}

// NewResizeVirtualMachineRequestWithBody generates requests for ResizeVirtualMachine with any type of body
func NewResizeVirtualMachineRequestWithBody(server string, vmId int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vm_id", runtime.ParamLocationPath, vmId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s/resize", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateSnapshotFromAVirtualMachineRequest calls the generic CreateSnapshotFromAVirtualMachine builder with application/json body
func NewCreateSnapshotFromAVirtualMachineRequest(server string, vmId int, body CreateSnapshotFromAVirtualMachineJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSnapshotFromAVirtualMachineRequestWithBody(server, vmId, "application/json", bodyReader)
}

// NewCreateSnapshotFromAVirtualMachineRequestWithBody generates requests for CreateSnapshotFromAVirtualMachine with any type of body
func NewCreateSnapshotFromAVirtualMachineRequestWithBody(server string, vmId int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vm_id", runtime.ParamLocationPath, vmId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s/snapshots", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStartVirtualMachineRequest generates requests for StartVirtualMachine
func NewStartVirtualMachineRequest(server string, vmId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vm_id", runtime.ParamLocationPath, vmId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s/start", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStopVirtualMachineRequest generates requests for StopVirtualMachine
func NewStopVirtualMachineRequest(server string, vmId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vm_id", runtime.ParamLocationPath, vmId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s/stop", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListVirtualMachinesWithResponse request
	ListVirtualMachinesWithResponse(ctx context.Context, params *ListVirtualMachinesParams, reqEditors ...RequestEditorFn) (*ListVirtualMachinesResponse, error)

	// CreateVirtualMachinesWithBodyWithResponse request with any body
	CreateVirtualMachinesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVirtualMachinesResponse, error)

	CreateVirtualMachinesWithResponse(ctx context.Context, body CreateVirtualMachinesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVirtualMachinesResponse, error)

	// RetrieveVirtualMachinesAssociatedWithAContractWithResponse request
	RetrieveVirtualMachinesAssociatedWithAContractWithResponse(ctx context.Context, contractId int, params *RetrieveVirtualMachinesAssociatedWithAContractParams, reqEditors ...RequestEditorFn) (*RetrieveVirtualMachinesAssociatedWithAContractResponse, error)

	// FetchVirtualMachineNameAvailabilityWithResponse request
	FetchVirtualMachineNameAvailabilityWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*FetchVirtualMachineNameAvailabilityResponse, error)

	// AddFirewallRuleToVirtualMachineWithBodyWithResponse request with any body
	AddFirewallRuleToVirtualMachineWithBodyWithResponse(ctx context.Context, virtualMachineId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddFirewallRuleToVirtualMachineResponse, error)

	AddFirewallRuleToVirtualMachineWithResponse(ctx context.Context, virtualMachineId int, body AddFirewallRuleToVirtualMachineJSONRequestBody, reqEditors ...RequestEditorFn) (*AddFirewallRuleToVirtualMachineResponse, error)

	// DeleteFirewallRuleFromVirtualMachineWithResponse request
	DeleteFirewallRuleFromVirtualMachineWithResponse(ctx context.Context, virtualMachineId int, id int, reqEditors ...RequestEditorFn) (*DeleteFirewallRuleFromVirtualMachineResponse, error)

	// DeleteVirtualMachineWithResponse request
	DeleteVirtualMachineWithResponse(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*DeleteVirtualMachineResponse, error)

	// RetrieveVirtualMachineDetailsWithResponse request
	RetrieveVirtualMachineDetailsWithResponse(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*RetrieveVirtualMachineDetailsResponse, error)

	// AttachFirewallsToAVirtualMachineWithBodyWithResponse request with any body
	AttachFirewallsToAVirtualMachineWithBodyWithResponse(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachFirewallsToAVirtualMachineResponse, error)

	AttachFirewallsToAVirtualMachineWithResponse(ctx context.Context, vmId int, body AttachFirewallsToAVirtualMachineJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachFirewallsToAVirtualMachineResponse, error)

	// HardRebootVirtualMachineWithResponse request
	HardRebootVirtualMachineWithResponse(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*HardRebootVirtualMachineResponse, error)

	// HibernateVirtualMachineWithResponse request
	HibernateVirtualMachineWithResponse(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*HibernateVirtualMachineResponse, error)

	// RestoreVirtualMachineFromHibernationWithResponse request
	RestoreVirtualMachineFromHibernationWithResponse(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*RestoreVirtualMachineFromHibernationResponse, error)

	// EditVirtualMachineLabelsWithBodyWithResponse request with any body
	EditVirtualMachineLabelsWithBodyWithResponse(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditVirtualMachineLabelsResponse, error)

	EditVirtualMachineLabelsWithResponse(ctx context.Context, vmId int, body EditVirtualMachineLabelsJSONRequestBody, reqEditors ...RequestEditorFn) (*EditVirtualMachineLabelsResponse, error)

	// RetrieveVirtualMachinePerformanceMetricsWithResponse request
	RetrieveVirtualMachinePerformanceMetricsWithResponse(ctx context.Context, vmId int, params *RetrieveVirtualMachinePerformanceMetricsParams, reqEditors ...RequestEditorFn) (*RetrieveVirtualMachinePerformanceMetricsResponse, error)

	// ResizeVirtualMachineWithBodyWithResponse request with any body
	ResizeVirtualMachineWithBodyWithResponse(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResizeVirtualMachineResponse, error)

	ResizeVirtualMachineWithResponse(ctx context.Context, vmId int, body ResizeVirtualMachineJSONRequestBody, reqEditors ...RequestEditorFn) (*ResizeVirtualMachineResponse, error)

	// CreateSnapshotFromAVirtualMachineWithBodyWithResponse request with any body
	CreateSnapshotFromAVirtualMachineWithBodyWithResponse(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSnapshotFromAVirtualMachineResponse, error)

	CreateSnapshotFromAVirtualMachineWithResponse(ctx context.Context, vmId int, body CreateSnapshotFromAVirtualMachineJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSnapshotFromAVirtualMachineResponse, error)

	// StartVirtualMachineWithResponse request
	StartVirtualMachineWithResponse(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*StartVirtualMachineResponse, error)

	// StopVirtualMachineWithResponse request
	StopVirtualMachineWithResponse(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*StopVirtualMachineResponse, error)
}

type ListVirtualMachinesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Instances
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r ListVirtualMachinesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListVirtualMachinesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVirtualMachinesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateInstancesResponse
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
	JSON405      *ErrorResponseModel
	JSON409      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r CreateVirtualMachinesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVirtualMachinesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrieveVirtualMachinesAssociatedWithAContractResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContractInstancesResponse
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r RetrieveVirtualMachinesAssociatedWithAContractResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveVirtualMachinesAssociatedWithAContractResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FetchVirtualMachineNameAvailabilityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NameAvailableModel
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r FetchVirtualMachineNameAvailabilityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchVirtualMachineNameAvailabilityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddFirewallRuleToVirtualMachineResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SecurityGroupRule
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
	JSON409      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r AddFirewallRuleToVirtualMachineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddFirewallRuleToVirtualMachineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFirewallRuleFromVirtualMachineResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseModel
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r DeleteFirewallRuleFromVirtualMachineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFirewallRuleFromVirtualMachineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVirtualMachineResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseModel
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
	JSON409      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r DeleteVirtualMachineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVirtualMachineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrieveVirtualMachineDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Instance
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r RetrieveVirtualMachineDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveVirtualMachineDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachFirewallsToAVirtualMachineResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseModel
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r AttachFirewallsToAVirtualMachineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachFirewallsToAVirtualMachineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HardRebootVirtualMachineResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseModel
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r HardRebootVirtualMachineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HardRebootVirtualMachineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HibernateVirtualMachineResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseModel
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r HibernateVirtualMachineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HibernateVirtualMachineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreVirtualMachineFromHibernationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseModel
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r RestoreVirtualMachineFromHibernationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreVirtualMachineFromHibernationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditVirtualMachineLabelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseModel
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
	JSON409      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r EditVirtualMachineLabelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditVirtualMachineLabelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrieveVirtualMachinePerformanceMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetricsFields
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
	JSON406      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r RetrieveVirtualMachinePerformanceMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveVirtualMachinePerformanceMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResizeVirtualMachineResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseModel
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
	JSON405      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r ResizeVirtualMachineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResizeVirtualMachineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSnapshotFromAVirtualMachineResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CreateSnapshotResponse
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r CreateSnapshotFromAVirtualMachineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSnapshotFromAVirtualMachineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartVirtualMachineResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseModel
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r StartVirtualMachineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartVirtualMachineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StopVirtualMachineResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseModel
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r StopVirtualMachineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StopVirtualMachineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListVirtualMachinesWithResponse request returning *ListVirtualMachinesResponse
func (c *ClientWithResponses) ListVirtualMachinesWithResponse(ctx context.Context, params *ListVirtualMachinesParams, reqEditors ...RequestEditorFn) (*ListVirtualMachinesResponse, error) {
	rsp, err := c.ListVirtualMachines(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListVirtualMachinesResponse(rsp)
}

// CreateVirtualMachinesWithBodyWithResponse request with arbitrary body returning *CreateVirtualMachinesResponse
func (c *ClientWithResponses) CreateVirtualMachinesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVirtualMachinesResponse, error) {
	rsp, err := c.CreateVirtualMachinesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVirtualMachinesResponse(rsp)
}

func (c *ClientWithResponses) CreateVirtualMachinesWithResponse(ctx context.Context, body CreateVirtualMachinesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVirtualMachinesResponse, error) {
	rsp, err := c.CreateVirtualMachines(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVirtualMachinesResponse(rsp)
}

// RetrieveVirtualMachinesAssociatedWithAContractWithResponse request returning *RetrieveVirtualMachinesAssociatedWithAContractResponse
func (c *ClientWithResponses) RetrieveVirtualMachinesAssociatedWithAContractWithResponse(ctx context.Context, contractId int, params *RetrieveVirtualMachinesAssociatedWithAContractParams, reqEditors ...RequestEditorFn) (*RetrieveVirtualMachinesAssociatedWithAContractResponse, error) {
	rsp, err := c.RetrieveVirtualMachinesAssociatedWithAContract(ctx, contractId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveVirtualMachinesAssociatedWithAContractResponse(rsp)
}

// FetchVirtualMachineNameAvailabilityWithResponse request returning *FetchVirtualMachineNameAvailabilityResponse
func (c *ClientWithResponses) FetchVirtualMachineNameAvailabilityWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*FetchVirtualMachineNameAvailabilityResponse, error) {
	rsp, err := c.FetchVirtualMachineNameAvailability(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFetchVirtualMachineNameAvailabilityResponse(rsp)
}

// AddFirewallRuleToVirtualMachineWithBodyWithResponse request with arbitrary body returning *AddFirewallRuleToVirtualMachineResponse
func (c *ClientWithResponses) AddFirewallRuleToVirtualMachineWithBodyWithResponse(ctx context.Context, virtualMachineId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddFirewallRuleToVirtualMachineResponse, error) {
	rsp, err := c.AddFirewallRuleToVirtualMachineWithBody(ctx, virtualMachineId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddFirewallRuleToVirtualMachineResponse(rsp)
}

func (c *ClientWithResponses) AddFirewallRuleToVirtualMachineWithResponse(ctx context.Context, virtualMachineId int, body AddFirewallRuleToVirtualMachineJSONRequestBody, reqEditors ...RequestEditorFn) (*AddFirewallRuleToVirtualMachineResponse, error) {
	rsp, err := c.AddFirewallRuleToVirtualMachine(ctx, virtualMachineId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddFirewallRuleToVirtualMachineResponse(rsp)
}

// DeleteFirewallRuleFromVirtualMachineWithResponse request returning *DeleteFirewallRuleFromVirtualMachineResponse
func (c *ClientWithResponses) DeleteFirewallRuleFromVirtualMachineWithResponse(ctx context.Context, virtualMachineId int, id int, reqEditors ...RequestEditorFn) (*DeleteFirewallRuleFromVirtualMachineResponse, error) {
	rsp, err := c.DeleteFirewallRuleFromVirtualMachine(ctx, virtualMachineId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFirewallRuleFromVirtualMachineResponse(rsp)
}

// DeleteVirtualMachineWithResponse request returning *DeleteVirtualMachineResponse
func (c *ClientWithResponses) DeleteVirtualMachineWithResponse(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*DeleteVirtualMachineResponse, error) {
	rsp, err := c.DeleteVirtualMachine(ctx, vmId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVirtualMachineResponse(rsp)
}

// RetrieveVirtualMachineDetailsWithResponse request returning *RetrieveVirtualMachineDetailsResponse
func (c *ClientWithResponses) RetrieveVirtualMachineDetailsWithResponse(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*RetrieveVirtualMachineDetailsResponse, error) {
	rsp, err := c.RetrieveVirtualMachineDetails(ctx, vmId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveVirtualMachineDetailsResponse(rsp)
}

// AttachFirewallsToAVirtualMachineWithBodyWithResponse request with arbitrary body returning *AttachFirewallsToAVirtualMachineResponse
func (c *ClientWithResponses) AttachFirewallsToAVirtualMachineWithBodyWithResponse(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachFirewallsToAVirtualMachineResponse, error) {
	rsp, err := c.AttachFirewallsToAVirtualMachineWithBody(ctx, vmId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachFirewallsToAVirtualMachineResponse(rsp)
}

func (c *ClientWithResponses) AttachFirewallsToAVirtualMachineWithResponse(ctx context.Context, vmId int, body AttachFirewallsToAVirtualMachineJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachFirewallsToAVirtualMachineResponse, error) {
	rsp, err := c.AttachFirewallsToAVirtualMachine(ctx, vmId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachFirewallsToAVirtualMachineResponse(rsp)
}

// HardRebootVirtualMachineWithResponse request returning *HardRebootVirtualMachineResponse
func (c *ClientWithResponses) HardRebootVirtualMachineWithResponse(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*HardRebootVirtualMachineResponse, error) {
	rsp, err := c.HardRebootVirtualMachine(ctx, vmId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHardRebootVirtualMachineResponse(rsp)
}

// HibernateVirtualMachineWithResponse request returning *HibernateVirtualMachineResponse
func (c *ClientWithResponses) HibernateVirtualMachineWithResponse(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*HibernateVirtualMachineResponse, error) {
	rsp, err := c.HibernateVirtualMachine(ctx, vmId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHibernateVirtualMachineResponse(rsp)
}

// RestoreVirtualMachineFromHibernationWithResponse request returning *RestoreVirtualMachineFromHibernationResponse
func (c *ClientWithResponses) RestoreVirtualMachineFromHibernationWithResponse(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*RestoreVirtualMachineFromHibernationResponse, error) {
	rsp, err := c.RestoreVirtualMachineFromHibernation(ctx, vmId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreVirtualMachineFromHibernationResponse(rsp)
}

// EditVirtualMachineLabelsWithBodyWithResponse request with arbitrary body returning *EditVirtualMachineLabelsResponse
func (c *ClientWithResponses) EditVirtualMachineLabelsWithBodyWithResponse(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditVirtualMachineLabelsResponse, error) {
	rsp, err := c.EditVirtualMachineLabelsWithBody(ctx, vmId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditVirtualMachineLabelsResponse(rsp)
}

func (c *ClientWithResponses) EditVirtualMachineLabelsWithResponse(ctx context.Context, vmId int, body EditVirtualMachineLabelsJSONRequestBody, reqEditors ...RequestEditorFn) (*EditVirtualMachineLabelsResponse, error) {
	rsp, err := c.EditVirtualMachineLabels(ctx, vmId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditVirtualMachineLabelsResponse(rsp)
}

// RetrieveVirtualMachinePerformanceMetricsWithResponse request returning *RetrieveVirtualMachinePerformanceMetricsResponse
func (c *ClientWithResponses) RetrieveVirtualMachinePerformanceMetricsWithResponse(ctx context.Context, vmId int, params *RetrieveVirtualMachinePerformanceMetricsParams, reqEditors ...RequestEditorFn) (*RetrieveVirtualMachinePerformanceMetricsResponse, error) {
	rsp, err := c.RetrieveVirtualMachinePerformanceMetrics(ctx, vmId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveVirtualMachinePerformanceMetricsResponse(rsp)
}

// ResizeVirtualMachineWithBodyWithResponse request with arbitrary body returning *ResizeVirtualMachineResponse
func (c *ClientWithResponses) ResizeVirtualMachineWithBodyWithResponse(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResizeVirtualMachineResponse, error) {
	rsp, err := c.ResizeVirtualMachineWithBody(ctx, vmId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResizeVirtualMachineResponse(rsp)
}

func (c *ClientWithResponses) ResizeVirtualMachineWithResponse(ctx context.Context, vmId int, body ResizeVirtualMachineJSONRequestBody, reqEditors ...RequestEditorFn) (*ResizeVirtualMachineResponse, error) {
	rsp, err := c.ResizeVirtualMachine(ctx, vmId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResizeVirtualMachineResponse(rsp)
}

// CreateSnapshotFromAVirtualMachineWithBodyWithResponse request with arbitrary body returning *CreateSnapshotFromAVirtualMachineResponse
func (c *ClientWithResponses) CreateSnapshotFromAVirtualMachineWithBodyWithResponse(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSnapshotFromAVirtualMachineResponse, error) {
	rsp, err := c.CreateSnapshotFromAVirtualMachineWithBody(ctx, vmId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSnapshotFromAVirtualMachineResponse(rsp)
}

func (c *ClientWithResponses) CreateSnapshotFromAVirtualMachineWithResponse(ctx context.Context, vmId int, body CreateSnapshotFromAVirtualMachineJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSnapshotFromAVirtualMachineResponse, error) {
	rsp, err := c.CreateSnapshotFromAVirtualMachine(ctx, vmId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSnapshotFromAVirtualMachineResponse(rsp)
}

// StartVirtualMachineWithResponse request returning *StartVirtualMachineResponse
func (c *ClientWithResponses) StartVirtualMachineWithResponse(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*StartVirtualMachineResponse, error) {
	rsp, err := c.StartVirtualMachine(ctx, vmId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartVirtualMachineResponse(rsp)
}

// StopVirtualMachineWithResponse request returning *StopVirtualMachineResponse
func (c *ClientWithResponses) StopVirtualMachineWithResponse(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*StopVirtualMachineResponse, error) {
	rsp, err := c.StopVirtualMachine(ctx, vmId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStopVirtualMachineResponse(rsp)
}

// ParseListVirtualMachinesResponse parses an HTTP response from a ListVirtualMachinesWithResponse call
func ParseListVirtualMachinesResponse(rsp *http.Response) (*ListVirtualMachinesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListVirtualMachinesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Instances
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateVirtualMachinesResponse parses an HTTP response from a CreateVirtualMachinesWithResponse call
func ParseCreateVirtualMachinesResponse(rsp *http.Response) (*CreateVirtualMachinesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVirtualMachinesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateInstancesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseRetrieveVirtualMachinesAssociatedWithAContractResponse parses an HTTP response from a RetrieveVirtualMachinesAssociatedWithAContractWithResponse call
func ParseRetrieveVirtualMachinesAssociatedWithAContractResponse(rsp *http.Response) (*RetrieveVirtualMachinesAssociatedWithAContractResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveVirtualMachinesAssociatedWithAContractResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContractInstancesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFetchVirtualMachineNameAvailabilityResponse parses an HTTP response from a FetchVirtualMachineNameAvailabilityWithResponse call
func ParseFetchVirtualMachineNameAvailabilityResponse(rsp *http.Response) (*FetchVirtualMachineNameAvailabilityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FetchVirtualMachineNameAvailabilityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NameAvailableModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAddFirewallRuleToVirtualMachineResponse parses an HTTP response from a AddFirewallRuleToVirtualMachineWithResponse call
func ParseAddFirewallRuleToVirtualMachineResponse(rsp *http.Response) (*AddFirewallRuleToVirtualMachineResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddFirewallRuleToVirtualMachineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SecurityGroupRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseDeleteFirewallRuleFromVirtualMachineResponse parses an HTTP response from a DeleteFirewallRuleFromVirtualMachineWithResponse call
func ParseDeleteFirewallRuleFromVirtualMachineResponse(rsp *http.Response) (*DeleteFirewallRuleFromVirtualMachineResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFirewallRuleFromVirtualMachineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteVirtualMachineResponse parses an HTTP response from a DeleteVirtualMachineWithResponse call
func ParseDeleteVirtualMachineResponse(rsp *http.Response) (*DeleteVirtualMachineResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVirtualMachineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseRetrieveVirtualMachineDetailsResponse parses an HTTP response from a RetrieveVirtualMachineDetailsWithResponse call
func ParseRetrieveVirtualMachineDetailsResponse(rsp *http.Response) (*RetrieveVirtualMachineDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveVirtualMachineDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Instance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAttachFirewallsToAVirtualMachineResponse parses an HTTP response from a AttachFirewallsToAVirtualMachineWithResponse call
func ParseAttachFirewallsToAVirtualMachineResponse(rsp *http.Response) (*AttachFirewallsToAVirtualMachineResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachFirewallsToAVirtualMachineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseHardRebootVirtualMachineResponse parses an HTTP response from a HardRebootVirtualMachineWithResponse call
func ParseHardRebootVirtualMachineResponse(rsp *http.Response) (*HardRebootVirtualMachineResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HardRebootVirtualMachineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseHibernateVirtualMachineResponse parses an HTTP response from a HibernateVirtualMachineWithResponse call
func ParseHibernateVirtualMachineResponse(rsp *http.Response) (*HibernateVirtualMachineResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HibernateVirtualMachineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseRestoreVirtualMachineFromHibernationResponse parses an HTTP response from a RestoreVirtualMachineFromHibernationWithResponse call
func ParseRestoreVirtualMachineFromHibernationResponse(rsp *http.Response) (*RestoreVirtualMachineFromHibernationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreVirtualMachineFromHibernationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseEditVirtualMachineLabelsResponse parses an HTTP response from a EditVirtualMachineLabelsWithResponse call
func ParseEditVirtualMachineLabelsResponse(rsp *http.Response) (*EditVirtualMachineLabelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditVirtualMachineLabelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseRetrieveVirtualMachinePerformanceMetricsResponse parses an HTTP response from a RetrieveVirtualMachinePerformanceMetricsWithResponse call
func ParseRetrieveVirtualMachinePerformanceMetricsResponse(rsp *http.Response) (*RetrieveVirtualMachinePerformanceMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveVirtualMachinePerformanceMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetricsFields
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseResizeVirtualMachineResponse parses an HTTP response from a ResizeVirtualMachineWithResponse call
func ParseResizeVirtualMachineResponse(rsp *http.Response) (*ResizeVirtualMachineResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResizeVirtualMachineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseCreateSnapshotFromAVirtualMachineResponse parses an HTTP response from a CreateSnapshotFromAVirtualMachineWithResponse call
func ParseCreateSnapshotFromAVirtualMachineResponse(rsp *http.Response) (*CreateSnapshotFromAVirtualMachineResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSnapshotFromAVirtualMachineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateSnapshotResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseStartVirtualMachineResponse parses an HTTP response from a StartVirtualMachineWithResponse call
func ParseStartVirtualMachineResponse(rsp *http.Response) (*StartVirtualMachineResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartVirtualMachineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseStopVirtualMachineResponse parses an HTTP response from a StopVirtualMachineWithResponse call
func ParseStopVirtualMachineResponse(rsp *http.Response) (*StopVirtualMachineResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StopVirtualMachineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}
