// Package virtual_machine provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.2.0 DO NOT EDIT.
package virtual_machine

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"github.com/NexGenCloud/hyperstack-sdk-go/lib/time"

	"github.com/oapi-codegen/runtime"
)

// Defines values for CreateSecurityRulePayloadProtocol.
const (
	Ah        CreateSecurityRulePayloadProtocol = "ah"
	Any       CreateSecurityRulePayloadProtocol = "any"
	Dccp      CreateSecurityRulePayloadProtocol = "dccp"
	Egp       CreateSecurityRulePayloadProtocol = "egp"
	Esp       CreateSecurityRulePayloadProtocol = "esp"
	Gre       CreateSecurityRulePayloadProtocol = "gre"
	Hopopt    CreateSecurityRulePayloadProtocol = "hopopt"
	Icmp      CreateSecurityRulePayloadProtocol = "icmp"
	Icmpv6    CreateSecurityRulePayloadProtocol = "icmpv6"
	Igmp      CreateSecurityRulePayloadProtocol = "igmp"
	Ip        CreateSecurityRulePayloadProtocol = "ip"
	Ipip      CreateSecurityRulePayloadProtocol = "ipip"
	Ipv6Encap CreateSecurityRulePayloadProtocol = "ipv6-encap"
	Ipv6Frag  CreateSecurityRulePayloadProtocol = "ipv6-frag"
	Ipv6Icmp  CreateSecurityRulePayloadProtocol = "ipv6-icmp"
	Ipv6Nonxt CreateSecurityRulePayloadProtocol = "ipv6-nonxt"
	Ipv6Opts  CreateSecurityRulePayloadProtocol = "ipv6-opts"
	Ipv6Route CreateSecurityRulePayloadProtocol = "ipv6-route"
	Ospf      CreateSecurityRulePayloadProtocol = "ospf"
	Pgm       CreateSecurityRulePayloadProtocol = "pgm"
	Rsvp      CreateSecurityRulePayloadProtocol = "rsvp"
	Sctp      CreateSecurityRulePayloadProtocol = "sctp"
	Tcp       CreateSecurityRulePayloadProtocol = "tcp"
	Udp       CreateSecurityRulePayloadProtocol = "udp"
	Udplite   CreateSecurityRulePayloadProtocol = "udplite"
	Vrrp      CreateSecurityRulePayloadProtocol = "vrrp"
)

// Defines values for EnvironmentFeaturesGreenStatus.
const (
	GREEN          EnvironmentFeaturesGreenStatus = "GREEN"
	NOTGREEN       EnvironmentFeaturesGreenStatus = "NOT_GREEN"
	PARTIALLYGREEN EnvironmentFeaturesGreenStatus = "PARTIALLY_GREEN"
)

// AttachFirewallsToVMPayload defines model for AttachFirewallsToVMPayload.
type AttachFirewallsToVMPayload struct {
	// Firewalls Ids of the firewalls to be attached with a virtual machine.
	Firewalls []int `json:"firewalls"`
}

// ClusterFields defines model for ClusterFields.
type ClusterFields struct {
	ApiAddress        *string                   `json:"api_address,omitempty"`
	CreatedAt         *time.CustomTime                `json:"created_at,omitempty"`
	EnvironmentName   *string                   `json:"environment_name,omitempty"`
	Id                *int                      `json:"id,omitempty"`
	IsReconciling     *bool                     `json:"is_reconciling,omitempty"`
	KeypairName       *string                   `json:"keypair_name,omitempty"`
	KubeConfig        *string                   `json:"kube_config,omitempty"`
	KubernetesVersion *string                   `json:"kubernetes_version,omitempty"`
	MasterFlavor      *ClusterFlavorFields      `json:"master_flavor,omitempty"`
	Name              *string                   `json:"name,omitempty"`
	NodeGroups        *[]ClusterNodeGroupFields `json:"node_groups,omitempty"`
	Nodes             *[]ClusterNodeFields      `json:"nodes,omitempty"`
	Status            *string                   `json:"status,omitempty"`
	StatusReason      *string                   `json:"status_reason,omitempty"`
}

// ClusterNodeFields defines model for ClusterNodeFields.
type ClusterNodeFields struct {
	CreatedAt        *time.CustomTime                 `json:"created_at,omitempty"`
	Id               *int                       `json:"id,omitempty"`
	Instance         *ClusterNodeInstanceFields `json:"instance,omitempty"`
	IsBastion        *bool                      `json:"is_bastion,omitempty"`
	NodeGroupId      *int                       `json:"node_group_id,omitempty"`
	NodeGroupName    *string                    `json:"node_group_name,omitempty"`
	RequiresPublicIp *bool                      `json:"requires_public_ip,omitempty"`
	Role             *string                    `json:"role,omitempty"`
	Status           *string                    `json:"status,omitempty"`
	StatusReason     *string                    `json:"status_reason,omitempty"`
	UpdatedAt        *time.CustomTime                 `json:"updated_at,omitempty"`
}

// ClusterNodeGroupFields defines model for ClusterNodeGroupFields.
type ClusterNodeGroupFields struct {
	Count     *int                 `json:"count,omitempty"`
	CreatedAt *time.CustomTime           `json:"created_at,omitempty"`
	Flavor    *ClusterFlavorFields `json:"flavor,omitempty"`
	Id        *int                 `json:"id,omitempty"`
	MaxCount  *int                 `json:"max_count,omitempty"`
	MinCount  *int                 `json:"min_count,omitempty"`
	Name      *string              `json:"name,omitempty"`
	Role      *string              `json:"role,omitempty"`
	UpdatedAt *time.CustomTime           `json:"updated_at,omitempty"`
}

// ClusterNodeInstanceFields defines model for ClusterNodeInstanceFields.
type ClusterNodeInstanceFields struct {
	ContractId       *int    `json:"contract_id,omitempty"`
	FixedIp          *string `json:"fixed_ip,omitempty"`
	FloatingIp       *string `json:"floating_ip,omitempty"`
	FloatingIpStatus *string `json:"floating_ip_status,omitempty"`
	Id               *int    `json:"id,omitempty"`
	ImageId          *int    `json:"image_id,omitempty"`
	Name             *string `json:"name,omitempty"`
	Status           *string `json:"status,omitempty"`
}

// ClusterFlavorFields defines model for Cluster_Flavor_Fields.
type ClusterFlavorFields struct {
	Cpu       *int                    `json:"cpu,omitempty"`
	Disk      *int                    `json:"disk,omitempty"`
	Ephemeral *int                    `json:"ephemeral,omitempty"`
	Features  *map[string]interface{} `json:"features,omitempty"`
	Gpu       *string                 `json:"gpu,omitempty"`
	GpuCount  *int                    `json:"gpu_count,omitempty"`
	Id        *int                    `json:"id,omitempty"`
	Labels    *[]LableResonse         `json:"labels,omitempty"`
	Name      *string                 `json:"name,omitempty"`
	Ram       *float32                `json:"ram,omitempty"`
}

// ContractInstanceFields defines model for ContractInstanceFields.
type ContractInstanceFields struct {
	Cluster         *ClusterFields `json:"cluster,omitempty"`
	CreatedAt       *time.CustomTime     `json:"created_at,omitempty"`
	FlavorName      *string        `json:"flavor_name,omitempty"`
	GpuCount        *int           `json:"gpu_count,omitempty"`
	Id              *int           `json:"id,omitempty"`
	Name            *string        `json:"name,omitempty"`
	Status          *string        `json:"status,omitempty"`
	TerminationTime *time.CustomTime     `json:"termination_time,omitempty"`
	TotalUsageTime  *int           `json:"total_usage_time,omitempty"`
}

// ContractInstancesResponse defines model for ContractInstancesResponse.
type ContractInstancesResponse struct {
	Instances *[]ContractInstanceFields `json:"instances,omitempty"`
	Message   *string                   `json:"message,omitempty"`
	Status    *bool                     `json:"status,omitempty"`
}

// CreateInstancesResponse defines model for CreateInstancesResponse.
type CreateInstancesResponse struct {
	Instances *[]InstanceFields `json:"instances,omitempty"`
	Message   *string           `json:"message,omitempty"`
	Status    *bool             `json:"status,omitempty"`
}

// CreateSnapshotPayload defines model for CreateSnapshotPayload.
type CreateSnapshotPayload struct {
	// Description description
	Description string `json:"description"`

	// Labels Labels associated with snapshot
	Labels *[]string `json:"labels,omitempty"`

	// Name Snapshot name
	Name string `json:"name"`
}

// CreateSnapshotResponse defines model for CreateSnapshotResponse.
type CreateSnapshotResponse struct {
	Message  *string         `json:"message,omitempty"`
	Snapshot *SnapshotFields `json:"snapshot,omitempty"`
	Status   *bool           `json:"status,omitempty"`
}

// CreateInstancesPayload defines model for Create_Instances_Payload.
type CreateInstancesPayload struct {
	// AssignFloatingIp When this field is set to `true`, it attaches a [public IP address](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/floating-ip/) to the virtual machine, enabling internet accessibility.
	AssignFloatingIp *bool `json:"assign_floating_ip,omitempty"`

	// CallbackUrl An optional URL where actions performed on the virtual machine will be sent. For additional information on event callbacks, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/callbacks-vms/).
	CallbackUrl *string `json:"callback_url,omitempty"`

	// Count The number of virtual machines to be created.
	Count int `json:"count"`

	// CreateBootableVolume Indicates whether to create a bootable volume for the virtual machine. When set to `true`, a bootable volume will be created; the default value is `false`.
	CreateBootableVolume *bool `json:"create_bootable_volume,omitempty"`

	// EnablePortRandomization Indicates whether to enable port randomization.This setting is only effective if 'assign_floating_ip' is true. Defaults to true.
	EnablePortRandomization *bool `json:"enable_port_randomization,omitempty"`

	// EnvironmentName The name of the [environment](https://docs.hyperstack.cloud/docs/api-reference/core-resources/environments/) in which the virtual machine is to be created.
	EnvironmentName string              `json:"environment_name"`
	Flavor          *FlavorObjectFields `json:"flavor,omitempty"`

	// FlavorName The name of the GPU hardware configuration ([flavor](https://docs.hyperstack.cloud/docs/hardware/flavors)) for the virtual machines being created.
	FlavorName string `json:"flavor_name"`

	// ImageName The [operating system (OS) image](https://docs.hyperstack.cloud/docs/virtual-machines/images) name designated for installation on the virtual machine.It also accepts custom, private images, created from [existing snapshots](https://docs.hyperstack.cloud/docs/virtual-machines/custom-images).
	ImageName *string `json:"image_name,omitempty"`

	// KeyName The name of the existing SSH key pair to be used for secure access to the virtual machine. For additional information on SSH key pairs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/keypairs/).
	KeyName string    `json:"key_name"`
	Labels  *[]string `json:"labels,omitempty"`

	// Name The name of the virtual machine being created.
	Name          string                       `json:"name"`
	Profile       *ProfileObjectFields         `json:"profile,omitempty"`
	SecurityRules *[]CreateSecurityRulePayload `json:"security_rules,omitempty"`

	// UserData Optional initialization configuration commands to manage the configuration of a virtual machine at launch using cloud-init scripts. For more information about custom VM configuration using cloud-init, [**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/initialization-configuration).
	UserData *string `json:"user_data,omitempty"`

	// VolumeName The names of the volume(s) to be attached to the virtual machine being created.
	VolumeName *string `json:"volume_name,omitempty"`
}

// CreateSecurityRulePayload defines model for Create_Security_Rule_Payload.
type CreateSecurityRulePayload struct {
	// Direction The direction of traffic that the firewall rule applies to.
	Direction string `json:"direction"`

	// Ethertype The Ethernet type associated with the rule.
	Ethertype    string `json:"ethertype"`
	PortRangeMax *int   `json:"port_range_max,omitempty"`
	PortRangeMin *int   `json:"port_range_min,omitempty"`

	// Protocol The network protocol associated with the rule. Call the [`GET /core/sg-rules-protocols`](https://infrahub-api-doc.nexgencloud.com/#get-/core/sg-rules-protocols) endpoint to retrieve a list of permitted network protocols.
	Protocol CreateSecurityRulePayloadProtocol `json:"protocol"`

	// RemoteIpPrefix The IP address range that is allowed to access the specified port. Use "0.0.0.0/0" to allow any IP address.
	RemoteIpPrefix string `json:"remote_ip_prefix"`
}

// CreateSecurityRulePayloadProtocol The network protocol associated with the rule. Call the [`GET /core/sg-rules-protocols`](https://infrahub-api-doc.nexgencloud.com/#get-/core/sg-rules-protocols) endpoint to retrieve a list of permitted network protocols.
type CreateSecurityRulePayloadProtocol string

// EditLabelOfAnExistingVMPayload defines model for Edit_label_of_an_existing_VM_Payload.
type EditLabelOfAnExistingVMPayload struct {
	// Labels Multiple labels can be added by separating with spaces
	Labels *[]string `json:"labels,omitempty"`
}

// EnvironmentFeatures defines model for Environment_Features.
type EnvironmentFeatures struct {
	GreenStatus      *EnvironmentFeaturesGreenStatus `json:"green_status,omitempty"`
	NetworkOptimised *bool                           `json:"network_optimised,omitempty"`
}

// EnvironmentFeaturesGreenStatus defines model for EnvironmentFeatures.GreenStatus.
type EnvironmentFeaturesGreenStatus string

// ErrorResponseModel defines model for ErrorResponseModel.
type ErrorResponseModel struct {
	ErrorReason *string `json:"error_reason,omitempty"`
	Message     *string `json:"message,omitempty"`
	Status      *bool   `json:"status,omitempty"`
}

// FlavorLabelFields defines model for FlavorLabelFields.
type FlavorLabelFields struct {
	Id    *int    `json:"id,omitempty"`
	Label *string `json:"label,omitempty"`
}

// FlavorObjectFields defines model for Flavor_Object_Fields.
type FlavorObjectFields struct {
	Cpu      *int     `json:"cpu,omitempty"`
	Disk     *int     `json:"disk,omitempty"`
	Gpu      *string  `json:"gpu,omitempty"`
	GpuCount *int     `json:"gpu_count,omitempty"`
	Ram      *float32 `json:"ram,omitempty"`
}

// GetInstanceLogsData defines model for GetInstanceLogsData.
type GetInstanceLogsData struct {
	Logs *string `json:"logs,omitempty"`
}

// Instance defines model for Instance.
type Instance struct {
	Instance *InstanceFields `json:"instance,omitempty"`
	Message  *string         `json:"message,omitempty"`
	Status   *bool           `json:"status,omitempty"`
}

// InstanceResizePayload defines model for InstanceResizePayload.
type InstanceResizePayload struct {
	Flavor     *FlavorObjectFields `json:"flavor,omitempty"`
	FlavorName *string             `json:"flavor_name,omitempty"`
}

// InstanceEnvironmentFields defines model for Instance_Environment_Fields.
type InstanceEnvironmentFields struct {
	Features *EnvironmentFeatures `json:"features,omitempty"`
	Id       *int                 `json:"id,omitempty"`
	Name     *string              `json:"name,omitempty"`
	OrgId    *int                 `json:"org_id,omitempty"`
	Region   *string              `json:"region,omitempty"`
}

// InstanceFields defines model for Instance_Fields.
type InstanceFields struct {
	CallbackUrl             *string                           `json:"callback_url,omitempty"`
	ContractId              *int                              `json:"contract_id,omitempty"`
	CreatedAt               *time.CustomTime                        `json:"created_at,omitempty"`
	Environment             *InstanceEnvironmentFields        `json:"environment,omitempty"`
	Features                *map[string]interface{}           `json:"features,omitempty"`
	FixedIp                 *string                           `json:"fixed_ip,omitempty"`
	Flavor                  *InstanceFlavorFields             `json:"flavor,omitempty"`
	FloatingIp              *string                           `json:"floating_ip,omitempty"`
	FloatingIpStatus        *string                           `json:"floating_ip_status,omitempty"`
	Id                      *int                              `json:"id,omitempty"`
	Image                   *InstanceImageFields              `json:"image,omitempty"`
	Keypair                 *InstanceKeypairFields            `json:"keypair,omitempty"`
	Labels                  *[]string                         `json:"labels,omitempty"`
	Locked                  *bool                             `json:"locked,omitempty"`
	Name                    *string                           `json:"name,omitempty"`
	Os                      *string                           `json:"os,omitempty"`
	PortRandomization       *bool                             `json:"port_randomization,omitempty"`
	PortRandomizationStatus *string                           `json:"port_randomization_status,omitempty"`
	PowerState              *string                           `json:"power_state,omitempty"`
	RequiresPublicIp        *bool                             `json:"requires_public_ip,omitempty"`
	SecurityRules           *[]SecurityRulesFieldsForInstance `json:"security_rules,omitempty"`
	Status                  *string                           `json:"status,omitempty"`
	VmState                 *string                           `json:"vm_state,omitempty"`
	VolumeAttachments       *[]VolumeAttachmentFields         `json:"volume_attachments,omitempty"`
}

// InstanceFlavorFields defines model for Instance_Flavor_Fields.
type InstanceFlavorFields struct {
	Cpu       *int                    `json:"cpu,omitempty"`
	Disk      *int                    `json:"disk,omitempty"`
	Ephemeral *int                    `json:"ephemeral,omitempty"`
	Features  *map[string]interface{} `json:"features,omitempty"`
	Gpu       *string                 `json:"gpu,omitempty"`
	GpuCount  *int                    `json:"gpu_count,omitempty"`
	Id        *int                    `json:"id,omitempty"`
	Labels    *[]FlavorLabelFields    `json:"labels,omitempty"`
	Name      *string                 `json:"name,omitempty"`
	Ram       *float32                `json:"ram,omitempty"`
}

// InstanceImageFields defines model for Instance_Image_Fields.
type InstanceImageFields struct {
	Name *string `json:"name,omitempty"`
}

// InstanceKeypairFields defines model for Instance_Keypair_Fields.
type InstanceKeypairFields struct {
	Name *string `json:"name,omitempty"`
}

// Instances defines model for Instances.
type Instances struct {
	Count     *int              `json:"count,omitempty"`
	Instances *[]InstanceFields `json:"instances,omitempty"`
	Message   *string           `json:"message,omitempty"`
	Page      *int              `json:"page,omitempty"`
	PageSize  *int              `json:"page_size,omitempty"`
	Status    *bool             `json:"status,omitempty"`
}

// LableResonse defines model for LableResonse.
type LableResonse struct {
	Id    *int    `json:"id,omitempty"`
	Label *string `json:"label,omitempty"`
}

// MetricItemFields defines model for MetricItemFields.
type MetricItemFields struct {
	Columns *[]string                   `json:"columns,omitempty"`
	Data    *[][]map[string]interface{} `json:"data,omitempty"`
	Unit    *string                     `json:"unit,omitempty"`
}

// MetricsFields defines model for MetricsFields.
type MetricsFields struct {
	Cpu          *MetricItemFields `json:"cpu,omitempty"`
	DiskRead     *MetricItemFields `json:"disk.read,omitempty"`
	DiskWrite    *MetricItemFields `json:"disk.write,omitempty"`
	MemoryUsages *MetricItemFields `json:"memory.usages,omitempty"`
	NetworkIn    *MetricItemFields `json:"network.in,omitempty"`
	NetworkOut   *MetricItemFields `json:"network.out,omitempty"`
}

// NameAvailableModel defines model for NameAvailableModel.
type NameAvailableModel struct {
	Available *bool   `json:"available,omitempty"`
	Message   *string `json:"message,omitempty"`
	Name      *string `json:"name,omitempty"`
}

// ProfileObjectFields defines model for Profile_Object_Fields.
type ProfileObjectFields struct {
	Description *string `json:"description,omitempty"`
	Name        string  `json:"name"`
}

// RequestInstanceLogsPayload defines model for RequestInstanceLogsPayload.
type RequestInstanceLogsPayload struct {
	// Length The amount of lines to fetch
	Length *int `json:"length,omitempty"`
}

// RequestInstanceLogsResponse defines model for RequestInstanceLogsResponse.
type RequestInstanceLogsResponse struct {
	RequestId *int `json:"request_id,omitempty"`
}

// ResponseModel defines model for ResponseModel.
type ResponseModel struct {
	Message *string `json:"message,omitempty"`
	Status  *bool   `json:"status,omitempty"`
}

// SecurityGroupRule defines model for Security_Group_Rule.
type SecurityGroupRule struct {
	Message      *string                  `json:"message,omitempty"`
	SecurityRule *SecurityGroupRuleFields `json:"security_rule,omitempty"`
	Status       *bool                    `json:"status,omitempty"`
}

// SecurityGroupRuleFields defines model for Security_Group_Rule_Fields.
type SecurityGroupRuleFields struct {
	CreatedAt      *time.CustomTime `json:"created_at,omitempty"`
	Direction      *string    `json:"direction,omitempty"`
	Ethertype      *string    `json:"ethertype,omitempty"`
	Id             *int       `json:"id,omitempty"`
	PortRangeMax   *int       `json:"port_range_max,omitempty"`
	PortRangeMin   *int       `json:"port_range_min,omitempty"`
	Protocol       *string    `json:"protocol,omitempty"`
	RemoteIpPrefix *string    `json:"remote_ip_prefix,omitempty"`
	Status         *string    `json:"status,omitempty"`
}

// SecurityRulesFieldsForInstance defines model for Security_Rules_Fields_for_Instance.
type SecurityRulesFieldsForInstance struct {
	CreatedAt      *time.CustomTime `json:"created_at,omitempty"`
	Direction      *string    `json:"direction,omitempty"`
	Ethertype      *string    `json:"ethertype,omitempty"`
	Id             *int       `json:"id,omitempty"`
	PortRangeMax   *int       `json:"port_range_max,omitempty"`
	PortRangeMin   *int       `json:"port_range_min,omitempty"`
	Protocol       *string    `json:"protocol,omitempty"`
	RemoteIpPrefix *string    `json:"remote_ip_prefix,omitempty"`
	Status         *string    `json:"status,omitempty"`
}

// SnapshotFields defines model for SnapshotFields.
type SnapshotFields struct {
	// CreatedAt Creation timestamp
	CreatedAt time.CustomTime `json:"created_at"`

	// Description Description of the snapshot
	Description string `json:"description"`

	// HasFloatingIp Indicates if the VM had a floating IP assigned
	HasFloatingIp *bool `json:"has_floating_ip,omitempty"`

	// Id Snapshot ID
	Id int `json:"id"`

	// IsImage Indicates if the snapshot is an image
	IsImage bool `json:"is_image"`

	// Labels Labels associated with snapshot
	Labels *[]string `json:"labels,omitempty"`

	// Name Snapshot name
	Name string `json:"name"`

	// RegionId Region where the snapshot will be available
	RegionId int `json:"region_id"`

	// Size Size in GB of the snapshot
	Size int `json:"size"`

	// Status Status of the snapshot
	Status string `json:"status"`

	// UpdatedAt Last update timestamp
	UpdatedAt time.CustomTime `json:"updated_at"`

	// VmId ID of the VM from which the snapshot is created
	VmId int `json:"vm_id"`
}

// VolumeAttachmentFields defines model for Volume_Attachment_Fields.
type VolumeAttachmentFields struct {
	CreatedAt *time.CustomTime               `json:"created_at,omitempty"`
	Device    *string                  `json:"device,omitempty"`
	Id        *int                     `json:"id,omitempty"`
	Protected *bool                    `json:"protected,omitempty"`
	Status    *string                  `json:"status,omitempty"`
	Volume    *VolumeFieldsForInstance `json:"volume,omitempty"`
}

// VolumeFieldsForInstance defines model for Volume_Fields_for_Instance.
type VolumeFieldsForInstance struct {
	Bootable    *bool   `json:"bootable,omitempty"`
	Description *string `json:"description,omitempty"`
	Id          *int    `json:"id,omitempty"`
	Name        *string `json:"name,omitempty"`
	Size        *int    `json:"size,omitempty"`
	VolumeType  *string `json:"volume_type,omitempty"`
}

// ListVMsParams defines parameters for ListVMs.
type ListVMsParams struct {
	Page             *int           `form:"page,omitempty" json:"page,omitempty"`
	PageSize         *int           `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	Search           *string        `form:"search,omitempty" json:"search,omitempty"`
	Environment      *string        `form:"environment,omitempty" json:"environment,omitempty"`
	ExcludeFirewalls *[]interface{} `form:"exclude_firewalls,omitempty" json:"exclude_firewalls,omitempty"`
}

// GetContractVMsParams defines parameters for GetContractVMs.
type GetContractVMsParams struct {
	Page     *string `form:"page,omitempty" json:"page,omitempty"`
	PageSize *string `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	Search   *string `form:"search,omitempty" json:"search,omitempty"`
}

// HibernateVMParams defines parameters for HibernateVM.
type HibernateVMParams struct {
	RetainIp *string `form:"retain_ip,omitempty" json:"retain_ip,omitempty"`
}

// GetVMLogsParams defines parameters for GetVMLogs.
type GetVMLogsParams struct {
	RequestId int `form:"request_id" json:"request_id"`
}

// GetVMMetricsParams defines parameters for GetVMMetrics.
type GetVMMetricsParams struct {
	Duration *string `form:"duration,omitempty" json:"duration,omitempty"`
}

// CreateVMsJSONRequestBody defines body for CreateVMs for application/json ContentType.
type CreateVMsJSONRequestBody = CreateInstancesPayload

// AttachFirewallsToVMJSONRequestBody defines body for AttachFirewallsToVM for application/json ContentType.
type AttachFirewallsToVMJSONRequestBody = AttachFirewallsToVMPayload

// AddVMLabelJSONRequestBody defines body for AddVMLabel for application/json ContentType.
type AddVMLabelJSONRequestBody = EditLabelOfAnExistingVMPayload

// RequestVMLogsJSONRequestBody defines body for RequestVMLogs for application/json ContentType.
type RequestVMLogsJSONRequestBody = RequestInstanceLogsPayload

// ResizeVMJSONRequestBody defines body for ResizeVM for application/json ContentType.
type ResizeVMJSONRequestBody = InstanceResizePayload

// CreateFirewallRuleForVMJSONRequestBody defines body for CreateFirewallRuleForVM for application/json ContentType.
type CreateFirewallRuleForVMJSONRequestBody = CreateSecurityRulePayload

// CreateSnapshotForVMJSONRequestBody defines body for CreateSnapshotForVM for application/json ContentType.
type CreateSnapshotForVMJSONRequestBody = CreateSnapshotPayload

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListVMs request
	ListVMs(ctx context.Context, params *ListVMsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVMsWithBody request with any body
	CreateVMsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVMs(ctx context.Context, body CreateVMsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetContractVMs request
	GetContractVMs(ctx context.Context, contractId int, params *GetContractVMsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CheckVMNameAvailability request
	CheckVMNameAvailability(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVM request
	DeleteVM(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVM request
	GetVM(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachFirewallsToVMWithBody request with any body
	AttachFirewallsToVMWithBody(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AttachFirewallsToVM(ctx context.Context, vmId int, body AttachFirewallsToVMJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HardRebootVM request
	HardRebootVM(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HibernateVM request
	HibernateVM(ctx context.Context, vmId int, params *HibernateVMParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RestoreVMFromHibernation request
	RestoreVMFromHibernation(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddVMLabelWithBody request with any body
	AddVMLabelWithBody(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddVMLabel(ctx context.Context, vmId int, body AddVMLabelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVMLogs request
	GetVMLogs(ctx context.Context, vmId int, params *GetVMLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RequestVMLogsWithBody request with any body
	RequestVMLogsWithBody(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RequestVMLogs(ctx context.Context, vmId int, body RequestVMLogsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVMMetrics request
	GetVMMetrics(ctx context.Context, vmId int, params *GetVMMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResizeVMWithBody request with any body
	ResizeVMWithBody(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResizeVM(ctx context.Context, vmId int, body ResizeVMJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFirewallRuleForVMWithBody request with any body
	CreateFirewallRuleForVMWithBody(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateFirewallRuleForVM(ctx context.Context, vmId int, body CreateFirewallRuleForVMJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFirewallRuleForVM request
	DeleteFirewallRuleForVM(ctx context.Context, vmId int, sgRuleId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSnapshotForVMWithBody request with any body
	CreateSnapshotForVMWithBody(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSnapshotForVM(ctx context.Context, vmId int, body CreateSnapshotForVMJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartVM request
	StartVM(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StopVM request
	StopVM(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListVMs(ctx context.Context, params *ListVMsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListVMsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVMsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVMsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVMs(ctx context.Context, body CreateVMsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVMsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetContractVMs(ctx context.Context, contractId int, params *GetContractVMsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetContractVMsRequest(c.Server, contractId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckVMNameAvailability(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckVMNameAvailabilityRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVM(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVMRequest(c.Server, vmId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVM(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVMRequest(c.Server, vmId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachFirewallsToVMWithBody(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachFirewallsToVMRequestWithBody(c.Server, vmId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachFirewallsToVM(ctx context.Context, vmId int, body AttachFirewallsToVMJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachFirewallsToVMRequest(c.Server, vmId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HardRebootVM(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHardRebootVMRequest(c.Server, vmId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HibernateVM(ctx context.Context, vmId int, params *HibernateVMParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHibernateVMRequest(c.Server, vmId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreVMFromHibernation(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreVMFromHibernationRequest(c.Server, vmId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddVMLabelWithBody(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddVMLabelRequestWithBody(c.Server, vmId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddVMLabel(ctx context.Context, vmId int, body AddVMLabelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddVMLabelRequest(c.Server, vmId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVMLogs(ctx context.Context, vmId int, params *GetVMLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVMLogsRequest(c.Server, vmId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RequestVMLogsWithBody(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRequestVMLogsRequestWithBody(c.Server, vmId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RequestVMLogs(ctx context.Context, vmId int, body RequestVMLogsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRequestVMLogsRequest(c.Server, vmId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVMMetrics(ctx context.Context, vmId int, params *GetVMMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVMMetricsRequest(c.Server, vmId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResizeVMWithBody(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResizeVMRequestWithBody(c.Server, vmId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResizeVM(ctx context.Context, vmId int, body ResizeVMJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResizeVMRequest(c.Server, vmId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFirewallRuleForVMWithBody(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFirewallRuleForVMRequestWithBody(c.Server, vmId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFirewallRuleForVM(ctx context.Context, vmId int, body CreateFirewallRuleForVMJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFirewallRuleForVMRequest(c.Server, vmId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFirewallRuleForVM(ctx context.Context, vmId int, sgRuleId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFirewallRuleForVMRequest(c.Server, vmId, sgRuleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSnapshotForVMWithBody(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSnapshotForVMRequestWithBody(c.Server, vmId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSnapshotForVM(ctx context.Context, vmId int, body CreateSnapshotForVMJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSnapshotForVMRequest(c.Server, vmId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartVM(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartVMRequest(c.Server, vmId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StopVM(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopVMRequest(c.Server, vmId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListVMsRequest generates requests for ListVMs
func NewListVMsRequest(server string, params *ListVMsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Environment != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "environment", runtime.ParamLocationQuery, *params.Environment); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeFirewalls != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_firewalls", runtime.ParamLocationQuery, *params.ExcludeFirewalls); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVMsRequest calls the generic CreateVMs builder with application/json body
func NewCreateVMsRequest(server string, body CreateVMsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVMsRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateVMsRequestWithBody generates requests for CreateVMs with any type of body
func NewCreateVMsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetContractVMsRequest generates requests for GetContractVMs
func NewGetContractVMsRequest(server string, contractId int, params *GetContractVMsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "contract_id", runtime.ParamLocationPath, contractId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/contract/%s/virtual-machines", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCheckVMNameAvailabilityRequest generates requests for CheckVMNameAvailability
func NewCheckVMNameAvailabilityRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/name-availability/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteVMRequest generates requests for DeleteVM
func NewDeleteVMRequest(server string, vmId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vm_id", runtime.ParamLocationPath, vmId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVMRequest generates requests for GetVM
func NewGetVMRequest(server string, vmId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vm_id", runtime.ParamLocationPath, vmId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAttachFirewallsToVMRequest calls the generic AttachFirewallsToVM builder with application/json body
func NewAttachFirewallsToVMRequest(server string, vmId int, body AttachFirewallsToVMJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAttachFirewallsToVMRequestWithBody(server, vmId, "application/json", bodyReader)
}

// NewAttachFirewallsToVMRequestWithBody generates requests for AttachFirewallsToVM with any type of body
func NewAttachFirewallsToVMRequestWithBody(server string, vmId int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vm_id", runtime.ParamLocationPath, vmId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s/attach-firewalls", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewHardRebootVMRequest generates requests for HardRebootVM
func NewHardRebootVMRequest(server string, vmId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vm_id", runtime.ParamLocationPath, vmId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s/hard-reboot", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHibernateVMRequest generates requests for HibernateVM
func NewHibernateVMRequest(server string, vmId int, params *HibernateVMParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vm_id", runtime.ParamLocationPath, vmId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s/hibernate", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RetainIp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "retain_ip", runtime.ParamLocationQuery, *params.RetainIp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreVMFromHibernationRequest generates requests for RestoreVMFromHibernation
func NewRestoreVMFromHibernationRequest(server string, vmId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vm_id", runtime.ParamLocationPath, vmId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s/hibernate-restore", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddVMLabelRequest calls the generic AddVMLabel builder with application/json body
func NewAddVMLabelRequest(server string, vmId int, body AddVMLabelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddVMLabelRequestWithBody(server, vmId, "application/json", bodyReader)
}

// NewAddVMLabelRequestWithBody generates requests for AddVMLabel with any type of body
func NewAddVMLabelRequestWithBody(server string, vmId int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vm_id", runtime.ParamLocationPath, vmId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s/label", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetVMLogsRequest generates requests for GetVMLogs
func NewGetVMLogsRequest(server string, vmId int, params *GetVMLogsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vm_id", runtime.ParamLocationPath, vmId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s/logs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "request_id", runtime.ParamLocationQuery, params.RequestId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRequestVMLogsRequest calls the generic RequestVMLogs builder with application/json body
func NewRequestVMLogsRequest(server string, vmId int, body RequestVMLogsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRequestVMLogsRequestWithBody(server, vmId, "application/json", bodyReader)
}

// NewRequestVMLogsRequestWithBody generates requests for RequestVMLogs with any type of body
func NewRequestVMLogsRequestWithBody(server string, vmId int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vm_id", runtime.ParamLocationPath, vmId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s/logs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetVMMetricsRequest generates requests for GetVMMetrics
func NewGetVMMetricsRequest(server string, vmId int, params *GetVMMetricsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vm_id", runtime.ParamLocationPath, vmId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s/metrics", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Duration != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "duration", runtime.ParamLocationQuery, *params.Duration); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewResizeVMRequest calls the generic ResizeVM builder with application/json body
func NewResizeVMRequest(server string, vmId int, body ResizeVMJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResizeVMRequestWithBody(server, vmId, "application/json", bodyReader)
}

// NewResizeVMRequestWithBody generates requests for ResizeVM with any type of body
func NewResizeVMRequestWithBody(server string, vmId int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vm_id", runtime.ParamLocationPath, vmId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s/resize", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateFirewallRuleForVMRequest calls the generic CreateFirewallRuleForVM builder with application/json body
func NewCreateFirewallRuleForVMRequest(server string, vmId int, body CreateFirewallRuleForVMJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFirewallRuleForVMRequestWithBody(server, vmId, "application/json", bodyReader)
}

// NewCreateFirewallRuleForVMRequestWithBody generates requests for CreateFirewallRuleForVM with any type of body
func NewCreateFirewallRuleForVMRequestWithBody(server string, vmId int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vm_id", runtime.ParamLocationPath, vmId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s/sg-rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFirewallRuleForVMRequest generates requests for DeleteFirewallRuleForVM
func NewDeleteFirewallRuleForVMRequest(server string, vmId int, sgRuleId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vm_id", runtime.ParamLocationPath, vmId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sg_rule_id", runtime.ParamLocationPath, sgRuleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s/sg-rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSnapshotForVMRequest calls the generic CreateSnapshotForVM builder with application/json body
func NewCreateSnapshotForVMRequest(server string, vmId int, body CreateSnapshotForVMJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSnapshotForVMRequestWithBody(server, vmId, "application/json", bodyReader)
}

// NewCreateSnapshotForVMRequestWithBody generates requests for CreateSnapshotForVM with any type of body
func NewCreateSnapshotForVMRequestWithBody(server string, vmId int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vm_id", runtime.ParamLocationPath, vmId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s/snapshots", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStartVMRequest generates requests for StartVM
func NewStartVMRequest(server string, vmId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vm_id", runtime.ParamLocationPath, vmId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s/start", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStopVMRequest generates requests for StopVM
func NewStopVMRequest(server string, vmId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vm_id", runtime.ParamLocationPath, vmId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s/stop", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListVMsWithResponse request
	ListVMsWithResponse(ctx context.Context, params *ListVMsParams, reqEditors ...RequestEditorFn) (*ListVMsResponse, error)

	// CreateVMsWithBodyWithResponse request with any body
	CreateVMsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVMsResponse, error)

	CreateVMsWithResponse(ctx context.Context, body CreateVMsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVMsResponse, error)

	// GetContractVMsWithResponse request
	GetContractVMsWithResponse(ctx context.Context, contractId int, params *GetContractVMsParams, reqEditors ...RequestEditorFn) (*GetContractVMsResponse, error)

	// CheckVMNameAvailabilityWithResponse request
	CheckVMNameAvailabilityWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*CheckVMNameAvailabilityResponse, error)

	// DeleteVMWithResponse request
	DeleteVMWithResponse(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*DeleteVMResponse, error)

	// GetVMWithResponse request
	GetVMWithResponse(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*GetVMResponse, error)

	// AttachFirewallsToVMWithBodyWithResponse request with any body
	AttachFirewallsToVMWithBodyWithResponse(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachFirewallsToVMResponse, error)

	AttachFirewallsToVMWithResponse(ctx context.Context, vmId int, body AttachFirewallsToVMJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachFirewallsToVMResponse, error)

	// HardRebootVMWithResponse request
	HardRebootVMWithResponse(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*HardRebootVMResponse, error)

	// HibernateVMWithResponse request
	HibernateVMWithResponse(ctx context.Context, vmId int, params *HibernateVMParams, reqEditors ...RequestEditorFn) (*HibernateVMResponse, error)

	// RestoreVMFromHibernationWithResponse request
	RestoreVMFromHibernationWithResponse(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*RestoreVMFromHibernationResponse, error)

	// AddVMLabelWithBodyWithResponse request with any body
	AddVMLabelWithBodyWithResponse(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddVMLabelResponse, error)

	AddVMLabelWithResponse(ctx context.Context, vmId int, body AddVMLabelJSONRequestBody, reqEditors ...RequestEditorFn) (*AddVMLabelResponse, error)

	// GetVMLogsWithResponse request
	GetVMLogsWithResponse(ctx context.Context, vmId int, params *GetVMLogsParams, reqEditors ...RequestEditorFn) (*GetVMLogsResponse, error)

	// RequestVMLogsWithBodyWithResponse request with any body
	RequestVMLogsWithBodyWithResponse(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RequestVMLogsResponse, error)

	RequestVMLogsWithResponse(ctx context.Context, vmId int, body RequestVMLogsJSONRequestBody, reqEditors ...RequestEditorFn) (*RequestVMLogsResponse, error)

	// GetVMMetricsWithResponse request
	GetVMMetricsWithResponse(ctx context.Context, vmId int, params *GetVMMetricsParams, reqEditors ...RequestEditorFn) (*GetVMMetricsResponse, error)

	// ResizeVMWithBodyWithResponse request with any body
	ResizeVMWithBodyWithResponse(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResizeVMResponse, error)

	ResizeVMWithResponse(ctx context.Context, vmId int, body ResizeVMJSONRequestBody, reqEditors ...RequestEditorFn) (*ResizeVMResponse, error)

	// CreateFirewallRuleForVMWithBodyWithResponse request with any body
	CreateFirewallRuleForVMWithBodyWithResponse(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFirewallRuleForVMResponse, error)

	CreateFirewallRuleForVMWithResponse(ctx context.Context, vmId int, body CreateFirewallRuleForVMJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFirewallRuleForVMResponse, error)

	// DeleteFirewallRuleForVMWithResponse request
	DeleteFirewallRuleForVMWithResponse(ctx context.Context, vmId int, sgRuleId int, reqEditors ...RequestEditorFn) (*DeleteFirewallRuleForVMResponse, error)

	// CreateSnapshotForVMWithBodyWithResponse request with any body
	CreateSnapshotForVMWithBodyWithResponse(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSnapshotForVMResponse, error)

	CreateSnapshotForVMWithResponse(ctx context.Context, vmId int, body CreateSnapshotForVMJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSnapshotForVMResponse, error)

	// StartVMWithResponse request
	StartVMWithResponse(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*StartVMResponse, error)

	// StopVMWithResponse request
	StopVMWithResponse(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*StopVMResponse, error)
}

type ListVMsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Instances
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r ListVMsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListVMsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVMsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateInstancesResponse
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
	JSON405      *ErrorResponseModel
	JSON409      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r CreateVMsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVMsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetContractVMsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContractInstancesResponse
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r GetContractVMsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContractVMsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CheckVMNameAvailabilityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NameAvailableModel
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r CheckVMNameAvailabilityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckVMNameAvailabilityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVMResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseModel
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
	JSON409      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r DeleteVMResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVMResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVMResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Instance
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r GetVMResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVMResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachFirewallsToVMResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseModel
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r AttachFirewallsToVMResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachFirewallsToVMResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HardRebootVMResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseModel
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r HardRebootVMResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HardRebootVMResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HibernateVMResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseModel
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r HibernateVMResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HibernateVMResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreVMFromHibernationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseModel
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r RestoreVMFromHibernationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreVMFromHibernationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddVMLabelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseModel
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
	JSON409      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r AddVMLabelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddVMLabelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVMLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetInstanceLogsData
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
	JSON405      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r GetVMLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVMLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RequestVMLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RequestInstanceLogsResponse
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
	JSON405      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r RequestVMLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RequestVMLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVMMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetricsFields
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
	JSON406      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r GetVMMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVMMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResizeVMResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseModel
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
	JSON405      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r ResizeVMResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResizeVMResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFirewallRuleForVMResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SecurityGroupRule
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
	JSON409      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r CreateFirewallRuleForVMResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFirewallRuleForVMResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFirewallRuleForVMResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseModel
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r DeleteFirewallRuleForVMResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFirewallRuleForVMResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSnapshotForVMResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CreateSnapshotResponse
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r CreateSnapshotForVMResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSnapshotForVMResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartVMResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseModel
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r StartVMResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartVMResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StopVMResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseModel
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r StopVMResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StopVMResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListVMsWithResponse request returning *ListVMsResponse
func (c *ClientWithResponses) ListVMsWithResponse(ctx context.Context, params *ListVMsParams, reqEditors ...RequestEditorFn) (*ListVMsResponse, error) {
	rsp, err := c.ListVMs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListVMsResponse(rsp)
}

// CreateVMsWithBodyWithResponse request with arbitrary body returning *CreateVMsResponse
func (c *ClientWithResponses) CreateVMsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVMsResponse, error) {
	rsp, err := c.CreateVMsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVMsResponse(rsp)
}

func (c *ClientWithResponses) CreateVMsWithResponse(ctx context.Context, body CreateVMsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVMsResponse, error) {
	rsp, err := c.CreateVMs(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVMsResponse(rsp)
}

// GetContractVMsWithResponse request returning *GetContractVMsResponse
func (c *ClientWithResponses) GetContractVMsWithResponse(ctx context.Context, contractId int, params *GetContractVMsParams, reqEditors ...RequestEditorFn) (*GetContractVMsResponse, error) {
	rsp, err := c.GetContractVMs(ctx, contractId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetContractVMsResponse(rsp)
}

// CheckVMNameAvailabilityWithResponse request returning *CheckVMNameAvailabilityResponse
func (c *ClientWithResponses) CheckVMNameAvailabilityWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*CheckVMNameAvailabilityResponse, error) {
	rsp, err := c.CheckVMNameAvailability(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckVMNameAvailabilityResponse(rsp)
}

// DeleteVMWithResponse request returning *DeleteVMResponse
func (c *ClientWithResponses) DeleteVMWithResponse(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*DeleteVMResponse, error) {
	rsp, err := c.DeleteVM(ctx, vmId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVMResponse(rsp)
}

// GetVMWithResponse request returning *GetVMResponse
func (c *ClientWithResponses) GetVMWithResponse(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*GetVMResponse, error) {
	rsp, err := c.GetVM(ctx, vmId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVMResponse(rsp)
}

// AttachFirewallsToVMWithBodyWithResponse request with arbitrary body returning *AttachFirewallsToVMResponse
func (c *ClientWithResponses) AttachFirewallsToVMWithBodyWithResponse(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachFirewallsToVMResponse, error) {
	rsp, err := c.AttachFirewallsToVMWithBody(ctx, vmId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachFirewallsToVMResponse(rsp)
}

func (c *ClientWithResponses) AttachFirewallsToVMWithResponse(ctx context.Context, vmId int, body AttachFirewallsToVMJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachFirewallsToVMResponse, error) {
	rsp, err := c.AttachFirewallsToVM(ctx, vmId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachFirewallsToVMResponse(rsp)
}

// HardRebootVMWithResponse request returning *HardRebootVMResponse
func (c *ClientWithResponses) HardRebootVMWithResponse(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*HardRebootVMResponse, error) {
	rsp, err := c.HardRebootVM(ctx, vmId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHardRebootVMResponse(rsp)
}

// HibernateVMWithResponse request returning *HibernateVMResponse
func (c *ClientWithResponses) HibernateVMWithResponse(ctx context.Context, vmId int, params *HibernateVMParams, reqEditors ...RequestEditorFn) (*HibernateVMResponse, error) {
	rsp, err := c.HibernateVM(ctx, vmId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHibernateVMResponse(rsp)
}

// RestoreVMFromHibernationWithResponse request returning *RestoreVMFromHibernationResponse
func (c *ClientWithResponses) RestoreVMFromHibernationWithResponse(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*RestoreVMFromHibernationResponse, error) {
	rsp, err := c.RestoreVMFromHibernation(ctx, vmId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreVMFromHibernationResponse(rsp)
}

// AddVMLabelWithBodyWithResponse request with arbitrary body returning *AddVMLabelResponse
func (c *ClientWithResponses) AddVMLabelWithBodyWithResponse(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddVMLabelResponse, error) {
	rsp, err := c.AddVMLabelWithBody(ctx, vmId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddVMLabelResponse(rsp)
}

func (c *ClientWithResponses) AddVMLabelWithResponse(ctx context.Context, vmId int, body AddVMLabelJSONRequestBody, reqEditors ...RequestEditorFn) (*AddVMLabelResponse, error) {
	rsp, err := c.AddVMLabel(ctx, vmId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddVMLabelResponse(rsp)
}

// GetVMLogsWithResponse request returning *GetVMLogsResponse
func (c *ClientWithResponses) GetVMLogsWithResponse(ctx context.Context, vmId int, params *GetVMLogsParams, reqEditors ...RequestEditorFn) (*GetVMLogsResponse, error) {
	rsp, err := c.GetVMLogs(ctx, vmId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVMLogsResponse(rsp)
}

// RequestVMLogsWithBodyWithResponse request with arbitrary body returning *RequestVMLogsResponse
func (c *ClientWithResponses) RequestVMLogsWithBodyWithResponse(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RequestVMLogsResponse, error) {
	rsp, err := c.RequestVMLogsWithBody(ctx, vmId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRequestVMLogsResponse(rsp)
}

func (c *ClientWithResponses) RequestVMLogsWithResponse(ctx context.Context, vmId int, body RequestVMLogsJSONRequestBody, reqEditors ...RequestEditorFn) (*RequestVMLogsResponse, error) {
	rsp, err := c.RequestVMLogs(ctx, vmId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRequestVMLogsResponse(rsp)
}

// GetVMMetricsWithResponse request returning *GetVMMetricsResponse
func (c *ClientWithResponses) GetVMMetricsWithResponse(ctx context.Context, vmId int, params *GetVMMetricsParams, reqEditors ...RequestEditorFn) (*GetVMMetricsResponse, error) {
	rsp, err := c.GetVMMetrics(ctx, vmId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVMMetricsResponse(rsp)
}

// ResizeVMWithBodyWithResponse request with arbitrary body returning *ResizeVMResponse
func (c *ClientWithResponses) ResizeVMWithBodyWithResponse(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResizeVMResponse, error) {
	rsp, err := c.ResizeVMWithBody(ctx, vmId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResizeVMResponse(rsp)
}

func (c *ClientWithResponses) ResizeVMWithResponse(ctx context.Context, vmId int, body ResizeVMJSONRequestBody, reqEditors ...RequestEditorFn) (*ResizeVMResponse, error) {
	rsp, err := c.ResizeVM(ctx, vmId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResizeVMResponse(rsp)
}

// CreateFirewallRuleForVMWithBodyWithResponse request with arbitrary body returning *CreateFirewallRuleForVMResponse
func (c *ClientWithResponses) CreateFirewallRuleForVMWithBodyWithResponse(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFirewallRuleForVMResponse, error) {
	rsp, err := c.CreateFirewallRuleForVMWithBody(ctx, vmId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFirewallRuleForVMResponse(rsp)
}

func (c *ClientWithResponses) CreateFirewallRuleForVMWithResponse(ctx context.Context, vmId int, body CreateFirewallRuleForVMJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFirewallRuleForVMResponse, error) {
	rsp, err := c.CreateFirewallRuleForVM(ctx, vmId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFirewallRuleForVMResponse(rsp)
}

// DeleteFirewallRuleForVMWithResponse request returning *DeleteFirewallRuleForVMResponse
func (c *ClientWithResponses) DeleteFirewallRuleForVMWithResponse(ctx context.Context, vmId int, sgRuleId int, reqEditors ...RequestEditorFn) (*DeleteFirewallRuleForVMResponse, error) {
	rsp, err := c.DeleteFirewallRuleForVM(ctx, vmId, sgRuleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFirewallRuleForVMResponse(rsp)
}

// CreateSnapshotForVMWithBodyWithResponse request with arbitrary body returning *CreateSnapshotForVMResponse
func (c *ClientWithResponses) CreateSnapshotForVMWithBodyWithResponse(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSnapshotForVMResponse, error) {
	rsp, err := c.CreateSnapshotForVMWithBody(ctx, vmId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSnapshotForVMResponse(rsp)
}

func (c *ClientWithResponses) CreateSnapshotForVMWithResponse(ctx context.Context, vmId int, body CreateSnapshotForVMJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSnapshotForVMResponse, error) {
	rsp, err := c.CreateSnapshotForVM(ctx, vmId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSnapshotForVMResponse(rsp)
}

// StartVMWithResponse request returning *StartVMResponse
func (c *ClientWithResponses) StartVMWithResponse(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*StartVMResponse, error) {
	rsp, err := c.StartVM(ctx, vmId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartVMResponse(rsp)
}

// StopVMWithResponse request returning *StopVMResponse
func (c *ClientWithResponses) StopVMWithResponse(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*StopVMResponse, error) {
	rsp, err := c.StopVM(ctx, vmId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStopVMResponse(rsp)
}

// ParseListVMsResponse parses an HTTP response from a ListVMsWithResponse call
func ParseListVMsResponse(rsp *http.Response) (*ListVMsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListVMsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Instances
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateVMsResponse parses an HTTP response from a CreateVMsWithResponse call
func ParseCreateVMsResponse(rsp *http.Response) (*CreateVMsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVMsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateInstancesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetContractVMsResponse parses an HTTP response from a GetContractVMsWithResponse call
func ParseGetContractVMsResponse(rsp *http.Response) (*GetContractVMsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetContractVMsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContractInstancesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCheckVMNameAvailabilityResponse parses an HTTP response from a CheckVMNameAvailabilityWithResponse call
func ParseCheckVMNameAvailabilityResponse(rsp *http.Response) (*CheckVMNameAvailabilityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CheckVMNameAvailabilityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NameAvailableModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteVMResponse parses an HTTP response from a DeleteVMWithResponse call
func ParseDeleteVMResponse(rsp *http.Response) (*DeleteVMResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVMResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetVMResponse parses an HTTP response from a GetVMWithResponse call
func ParseGetVMResponse(rsp *http.Response) (*GetVMResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVMResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Instance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAttachFirewallsToVMResponse parses an HTTP response from a AttachFirewallsToVMWithResponse call
func ParseAttachFirewallsToVMResponse(rsp *http.Response) (*AttachFirewallsToVMResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachFirewallsToVMResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseHardRebootVMResponse parses an HTTP response from a HardRebootVMWithResponse call
func ParseHardRebootVMResponse(rsp *http.Response) (*HardRebootVMResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HardRebootVMResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseHibernateVMResponse parses an HTTP response from a HibernateVMWithResponse call
func ParseHibernateVMResponse(rsp *http.Response) (*HibernateVMResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HibernateVMResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseRestoreVMFromHibernationResponse parses an HTTP response from a RestoreVMFromHibernationWithResponse call
func ParseRestoreVMFromHibernationResponse(rsp *http.Response) (*RestoreVMFromHibernationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreVMFromHibernationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAddVMLabelResponse parses an HTTP response from a AddVMLabelWithResponse call
func ParseAddVMLabelResponse(rsp *http.Response) (*AddVMLabelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddVMLabelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetVMLogsResponse parses an HTTP response from a GetVMLogsWithResponse call
func ParseGetVMLogsResponse(rsp *http.Response) (*GetVMLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVMLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetInstanceLogsData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseRequestVMLogsResponse parses an HTTP response from a RequestVMLogsWithResponse call
func ParseRequestVMLogsResponse(rsp *http.Response) (*RequestVMLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RequestVMLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RequestInstanceLogsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseGetVMMetricsResponse parses an HTTP response from a GetVMMetricsWithResponse call
func ParseGetVMMetricsResponse(rsp *http.Response) (*GetVMMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVMMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetricsFields
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseResizeVMResponse parses an HTTP response from a ResizeVMWithResponse call
func ParseResizeVMResponse(rsp *http.Response) (*ResizeVMResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResizeVMResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseCreateFirewallRuleForVMResponse parses an HTTP response from a CreateFirewallRuleForVMWithResponse call
func ParseCreateFirewallRuleForVMResponse(rsp *http.Response) (*CreateFirewallRuleForVMResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFirewallRuleForVMResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SecurityGroupRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseDeleteFirewallRuleForVMResponse parses an HTTP response from a DeleteFirewallRuleForVMWithResponse call
func ParseDeleteFirewallRuleForVMResponse(rsp *http.Response) (*DeleteFirewallRuleForVMResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFirewallRuleForVMResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateSnapshotForVMResponse parses an HTTP response from a CreateSnapshotForVMWithResponse call
func ParseCreateSnapshotForVMResponse(rsp *http.Response) (*CreateSnapshotForVMResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSnapshotForVMResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateSnapshotResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseStartVMResponse parses an HTTP response from a StartVMWithResponse call
func ParseStartVMResponse(rsp *http.Response) (*StartVMResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartVMResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseStopVMResponse parses an HTTP response from a StopVMWithResponse call
func ParseStopVMResponse(rsp *http.Response) (*StopVMResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StopVMResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}
