// Package virtual_machine provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package virtual_machine

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"github.com/NexGenCloud/hyperstack-sdk-go/lib/time"

	"github.com/oapi-codegen/runtime"
)

// Defines values for CreateSecurityRulePayloadProtocol.
const (
	Ah        CreateSecurityRulePayloadProtocol = "ah"
	Any       CreateSecurityRulePayloadProtocol = "any"
	Dccp      CreateSecurityRulePayloadProtocol = "dccp"
	Egp       CreateSecurityRulePayloadProtocol = "egp"
	Esp       CreateSecurityRulePayloadProtocol = "esp"
	Gre       CreateSecurityRulePayloadProtocol = "gre"
	Hopopt    CreateSecurityRulePayloadProtocol = "hopopt"
	Icmp      CreateSecurityRulePayloadProtocol = "icmp"
	Icmpv6    CreateSecurityRulePayloadProtocol = "icmpv6"
	Igmp      CreateSecurityRulePayloadProtocol = "igmp"
	Ip        CreateSecurityRulePayloadProtocol = "ip"
	Ipip      CreateSecurityRulePayloadProtocol = "ipip"
	Ipv6Encap CreateSecurityRulePayloadProtocol = "ipv6-encap"
	Ipv6Frag  CreateSecurityRulePayloadProtocol = "ipv6-frag"
	Ipv6Icmp  CreateSecurityRulePayloadProtocol = "ipv6-icmp"
	Ipv6Nonxt CreateSecurityRulePayloadProtocol = "ipv6-nonxt"
	Ipv6Opts  CreateSecurityRulePayloadProtocol = "ipv6-opts"
	Ipv6Route CreateSecurityRulePayloadProtocol = "ipv6-route"
	Ospf      CreateSecurityRulePayloadProtocol = "ospf"
	Pgm       CreateSecurityRulePayloadProtocol = "pgm"
	Rsvp      CreateSecurityRulePayloadProtocol = "rsvp"
	Sctp      CreateSecurityRulePayloadProtocol = "sctp"
	Tcp       CreateSecurityRulePayloadProtocol = "tcp"
	Udp       CreateSecurityRulePayloadProtocol = "udp"
	Udplite   CreateSecurityRulePayloadProtocol = "udplite"
	Vrrp      CreateSecurityRulePayloadProtocol = "vrrp"
)

// AttachFirewallsToVMPayload defines model for AttachFirewallsToVMPayload.
type AttachFirewallsToVMPayload struct {
	Firewalls []int `json:"firewalls"`
}

// ContractInstanceFields defines model for ContractInstanceFields.
type ContractInstanceFields struct {
	CreatedAt  *time.CustomTime `json:"created_at,omitempty"`
	FlavorName *string    `json:"flavor_name,omitempty"`
	GpuCount   *int       `json:"gpu_count,omitempty"`
	Id         *int       `json:"id,omitempty"`
	Name       *string    `json:"name,omitempty"`
	Status     *string    `json:"status,omitempty"`
}

// ContractInstancesResponse defines model for ContractInstancesResponse.
type ContractInstancesResponse struct {
	Instances *[]ContractInstanceFields `json:"instances,omitempty"`
	Message   *string                   `json:"message,omitempty"`
	Status    *bool                     `json:"status,omitempty"`
}

// CreateInstancesPayload defines model for CreateInstancesPayload.
type CreateInstancesPayload struct {
	// AssignFloatingIp When this field is set to `true`, it attaches a [public IP address](https://infrahub-doc.nexgencloud.com/docs/virtual-machines/public-ip) to the virtual machine, enabling internet accessibility.
	AssignFloatingIp *bool `json:"assign_floating_ip,omitempty"`

	// CallbackUrl An optional URL where actions performed on the virtual machine will be sent. For additional information on event callbacks, [**click here**](https://infrahub-doc.nexgencloud.com/docs/features/webhooks-callbacks).
	CallbackUrl *string `json:"callback_url,omitempty"`

	// Count The number of virtual machines to be created.
	Count int `json:"count"`

	// CreateBootableVolume Indicates whether to create a bootable volume for the virtual machine. When set to `true`, a bootable volume will be created; the default value is `false`.
	CreateBootableVolume *bool `json:"create_bootable_volume,omitempty"`

	// EnvironmentName The name of the [environment](https://infrahub-doc.nexgencloud.com/docs/features/environments-available-features) in which the virtual machine is to be created.
	EnvironmentName string              `json:"environment_name"`
	Flavor          *FlavorObjectFields `json:"flavor,omitempty"`

	// FlavorName The name of the GPU hardware configuration ([flavor](https://infrahub-doc.nexgencloud.com/docs/hardware/flavors)) for the virtual machines being created.
	FlavorName string `json:"flavor_name"`

	// ImageName The [operating system (OS) image](https://infrahub-doc.nexgencloud.com/docs/virtual-machines/images) name designated for installation on the virtual machine.
	ImageName *string `json:"image_name,omitempty"`

	// KeyName The name of the existing SSH key pair to be used for secure access to the virtual machine. For additional information on SSH key pairs, [**click here**](https://infrahub-doc.nexgencloud.com/docs/getting-started/create-keypair).
	KeyName string    `json:"key_name"`
	Labels  *[]string `json:"labels,omitempty"`

	// Name The name of the virtual machine being created.
	Name          string                       `json:"name"`
	Profile       *ProfileObjectFields         `json:"profile,omitempty"`
	SecurityRules *[]CreateSecurityRulePayload `json:"security_rules,omitempty"`

	// UserData Optional initialization configuration commands to manage the configuration of a virtual machine at launch using cloud-init scripts. For more information about custom VM configuration using cloud-init, [**click here**](https://infrahub-doc.nexgencloud.com/docs/virtual-machines/initialization-configuration).
	UserData *string `json:"user_data,omitempty"`

	// VolumeName The names of the volume(s) to be attached to the virtual machine being created.
	VolumeName *string `json:"volume_name,omitempty"`
}

// CreateInstancesResponse defines model for CreateInstancesResponse.
type CreateInstancesResponse struct {
	Instances *[]InstanceFields `json:"instances,omitempty"`
	Message   *string           `json:"message,omitempty"`
	Status    *bool             `json:"status,omitempty"`
}

// CreateSecurityRulePayload defines model for CreateSecurityRulePayload.
type CreateSecurityRulePayload struct {
	// Direction The direction of traffic that the firewall rule applies to.
	Direction string `json:"direction"`

	// Ethertype The Ethernet type associated with the rule.
	Ethertype    string `json:"ethertype"`
	PortRangeMax *int   `json:"port_range_max,omitempty"`
	PortRangeMin *int   `json:"port_range_min,omitempty"`

	// Protocol The network protocol associated with the rule. Call the [`GET /core/sg-rules-protocols`](https://infrahub-api-doc.nexgencloud.com/#get-/core/sg-rules-protocols) endpoint to retrieve a list of permitted network protocols.
	Protocol CreateSecurityRulePayloadProtocol `json:"protocol"`

	// RemoteIpPrefix The IP address range that is allowed to access the specified port. Use "0.0.0.0/0" to allow any IP address.
	RemoteIpPrefix string `json:"remote_ip_prefix"`
}

// CreateSecurityRulePayloadProtocol The network protocol associated with the rule. Call the [`GET /core/sg-rules-protocols`](https://infrahub-api-doc.nexgencloud.com/#get-/core/sg-rules-protocols) endpoint to retrieve a list of permitted network protocols.
type CreateSecurityRulePayloadProtocol string

// EditlabelofanexistingVMPayload defines model for EditlabelofanexistingVMPayload.
type EditlabelofanexistingVMPayload struct {
	Labels *[]string `json:"labels,omitempty"`
}

// ErrorResponseModel defines model for ErrorResponseModel.
type ErrorResponseModel struct {
	ErrorReason *string `json:"error_reason,omitempty"`
	Message     *string `json:"message,omitempty"`
	Status      *bool   `json:"status,omitempty"`
}

// FlavorObjectFields defines model for FlavorObjectFields.
type FlavorObjectFields struct {
	Cpu      *int     `json:"cpu,omitempty"`
	Disk     *int     `json:"disk,omitempty"`
	Gpu      *string  `json:"gpu,omitempty"`
	GpuCount *int     `json:"gpu_count,omitempty"`
	Ram      *float32 `json:"ram,omitempty"`
}

// Instance defines model for Instance.
type Instance struct {
	Instance *InstanceFields `json:"instance,omitempty"`
	Message  *string         `json:"message,omitempty"`
	Status   *bool           `json:"status,omitempty"`
}

// InstanceEnvironmentFields defines model for InstanceEnvironmentFields.
type InstanceEnvironmentFields struct {
	Id     *int    `json:"id,omitempty"`
	Name   *string `json:"name,omitempty"`
	OrgId  *int    `json:"org_id,omitempty"`
	Region *string `json:"region,omitempty"`
}

// InstanceFields defines model for InstanceFields.
type InstanceFields struct {
	ContractId        *int                              `json:"contract_id,omitempty"`
	CreatedAt         *time.CustomTime                        `json:"created_at,omitempty"`
	Environment       *InstanceEnvironmentFields        `json:"environment,omitempty"`
	FixedIp           *string                           `json:"fixed_ip,omitempty"`
	Flavor            *InstanceFlavorFields             `json:"flavor,omitempty"`
	FloatingIp        *string                           `json:"floating_ip,omitempty"`
	FloatingIpStatus  *string                           `json:"floating_ip_status,omitempty"`
	Id                *int                              `json:"id,omitempty"`
	Image             *InstanceImageFields              `json:"image,omitempty"`
	Keypair           *InstanceKeypairFields            `json:"keypair,omitempty"`
	Labels            *[]string                         `json:"labels,omitempty"`
	Locked            *bool                             `json:"locked,omitempty"`
	Name              *string                           `json:"name,omitempty"`
	Os                *string                           `json:"os,omitempty"`
	PowerState        *string                           `json:"power_state,omitempty"`
	SecurityRules     *[]SecurityRulesFieldsforInstance `json:"security_rules,omitempty"`
	Status            *string                           `json:"status,omitempty"`
	VmState           *string                           `json:"vm_state,omitempty"`
	VolumeAttachments *[]VolumeAttachmentFields         `json:"volume_attachments,omitempty"`
}

// InstanceFlavorFields defines model for InstanceFlavorFields.
type InstanceFlavorFields struct {
	Cpu       *int     `json:"cpu,omitempty"`
	Disk      *int     `json:"disk,omitempty"`
	Ephemeral *int     `json:"ephemeral,omitempty"`
	Gpu       *string  `json:"gpu,omitempty"`
	GpuCount  *int     `json:"gpu_count,omitempty"`
	Id        *int     `json:"id,omitempty"`
	Name      *string  `json:"name,omitempty"`
	Ram       *float32 `json:"ram,omitempty"`
}

// InstanceImageFields defines model for InstanceImageFields.
type InstanceImageFields struct {
	Name *string `json:"name,omitempty"`
}

// InstanceKeypairFields defines model for InstanceKeypairFields.
type InstanceKeypairFields struct {
	Name *string `json:"name,omitempty"`
}

// InstanceResizePayload defines model for InstanceResizePayload.
type InstanceResizePayload struct {
	Flavor     *FlavorObjectFields `json:"flavor,omitempty"`
	FlavorName *string             `json:"flavor_name,omitempty"`
}

// Instances defines model for Instances.
type Instances struct {
	Count     *int              `json:"count,omitempty"`
	Instances *[]InstanceFields `json:"instances,omitempty"`
	Message   *string           `json:"message,omitempty"`
	Page      *int              `json:"page,omitempty"`
	PageSize  *int              `json:"page_size,omitempty"`
	Status    *bool             `json:"status,omitempty"`
}

// MetricItemFields defines model for MetricItemFields.
type MetricItemFields struct {
	Columns *[]string                   `json:"columns,omitempty"`
	Data    *[][]map[string]interface{} `json:"data,omitempty"`
	Unit    *string                     `json:"unit,omitempty"`
}

// MetricsFields defines model for MetricsFields.
type MetricsFields struct {
	Cpu          *MetricItemFields `json:"cpu,omitempty"`
	DiskRead     *MetricItemFields `json:"disk.read,omitempty"`
	DiskWrite    *MetricItemFields `json:"disk.write,omitempty"`
	MemoryUsages *MetricItemFields `json:"memory.usages,omitempty"`
	NetworkIn    *MetricItemFields `json:"network.in,omitempty"`
	NetworkOut   *MetricItemFields `json:"network.out,omitempty"`
}

// ProfileObjectFields defines model for ProfileObjectFields.
type ProfileObjectFields struct {
	Description *string `json:"description,omitempty"`
	Name        string  `json:"name"`
}

// ResponseModel defines model for ResponseModel.
type ResponseModel struct {
	Message *string `json:"message,omitempty"`
	Status  *bool   `json:"status,omitempty"`
}

// SecurityGroupRule defines model for SecurityGroupRule.
type SecurityGroupRule struct {
	Message      *string                  `json:"message,omitempty"`
	SecurityRule *SecurityGroupRuleFields `json:"security_rule,omitempty"`
	Status       *bool                    `json:"status,omitempty"`
}

// SecurityGroupRuleFields defines model for SecurityGroupRuleFields.
type SecurityGroupRuleFields struct {
	CreatedAt      *time.CustomTime `json:"created_at,omitempty"`
	Direction      *string    `json:"direction,omitempty"`
	Ethertype      *string    `json:"ethertype,omitempty"`
	Id             *int       `json:"id,omitempty"`
	PortRangeMax   *int       `json:"port_range_max,omitempty"`
	PortRangeMin   *int       `json:"port_range_min,omitempty"`
	Protocol       *string    `json:"protocol,omitempty"`
	RemoteIpPrefix *string    `json:"remote_ip_prefix,omitempty"`
	Status         *string    `json:"status,omitempty"`
}

// SecurityRulesFieldsforInstance defines model for SecurityRulesFieldsforInstance.
type SecurityRulesFieldsforInstance struct {
	CreatedAt      *time.CustomTime `json:"created_at,omitempty"`
	Direction      *string    `json:"direction,omitempty"`
	Ethertype      *string    `json:"ethertype,omitempty"`
	Id             *int       `json:"id,omitempty"`
	PortRangeMax   *int       `json:"port_range_max,omitempty"`
	PortRangeMin   *int       `json:"port_range_min,omitempty"`
	Protocol       *string    `json:"protocol,omitempty"`
	RemoteIpPrefix *string    `json:"remote_ip_prefix,omitempty"`
	Status         *string    `json:"status,omitempty"`
}

// VolumeAttachmentFields defines model for VolumeAttachmentFields.
type VolumeAttachmentFields struct {
	CreatedAt *time.CustomTime               `json:"created_at,omitempty"`
	Device    *string                  `json:"device,omitempty"`
	Status    *string                  `json:"status,omitempty"`
	Volume    *VolumeFieldsforInstance `json:"volume,omitempty"`
}

// VolumeFieldsforInstance defines model for VolumeFieldsforInstance.
type VolumeFieldsforInstance struct {
	Description *string `json:"description,omitempty"`
	Id          *int    `json:"id,omitempty"`
	Name        *string `json:"name,omitempty"`
	Size        *int    `json:"size,omitempty"`
	VolumeType  *string `json:"volume_type,omitempty"`
}

// ListVirtualMachinesParams defines parameters for ListVirtualMachines.
type ListVirtualMachinesParams struct {
	Page     *string `form:"page,omitempty" json:"page,omitempty"`
	PageSize *string `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	Search   *string `form:"search,omitempty" json:"search,omitempty"`
}

// RetrieveVirtualMachinePerformanceMetricsParams defines parameters for RetrieveVirtualMachinePerformanceMetrics.
type RetrieveVirtualMachinePerformanceMetricsParams struct {
	Duration *string `form:"duration,omitempty" json:"duration,omitempty"`
}

// CreateVirtualMachineJSONRequestBody defines body for CreateVirtualMachine for application/json ContentType.
type CreateVirtualMachineJSONRequestBody = CreateInstancesPayload

// EditLabelsOfAnExistingVMJSONRequestBody defines body for EditLabelsOfAnExistingVM for application/json ContentType.
type EditLabelsOfAnExistingVMJSONRequestBody = EditlabelofanexistingVMPayload

// ResizeVirtualMachineJSONRequestBody defines body for ResizeVirtualMachine for application/json ContentType.
type ResizeVirtualMachineJSONRequestBody = InstanceResizePayload

// AddFirewallRuleToVirtualMachineJSONRequestBody defines body for AddFirewallRuleToVirtualMachine for application/json ContentType.
type AddFirewallRuleToVirtualMachineJSONRequestBody = CreateSecurityRulePayload

// AttachFirewallsToAVMJSONRequestBody defines body for AttachFirewallsToAVM for application/json ContentType.
type AttachFirewallsToAVMJSONRequestBody = AttachFirewallsToVMPayload

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListVirtualMachines request
	ListVirtualMachines(ctx context.Context, params *ListVirtualMachinesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVirtualMachineWithBody request with any body
	CreateVirtualMachineWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVirtualMachine(ctx context.Context, body CreateVirtualMachineJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrieveVirtualMachinesAssociatedWithAContract request
	RetrieveVirtualMachinesAssociatedWithAContract(ctx context.Context, contractId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVirtualMachine request
	DeleteVirtualMachine(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrieveVirtualMachineDetails request
	RetrieveVirtualMachineDetails(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HardRebootVirtualMachine request
	HardRebootVirtualMachine(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartVirtualMachine request
	StartVirtualMachine(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StopVirtualMachine request
	StopVirtualMachine(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HibernateVirtualMachine request
	HibernateVirtualMachine(ctx context.Context, virtualMachineId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RestoreVirtualMachineFromHibernation request
	RestoreVirtualMachineFromHibernation(ctx context.Context, virtualMachineId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditLabelsOfAnExistingVMWithBody request with any body
	EditLabelsOfAnExistingVMWithBody(ctx context.Context, virtualMachineId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditLabelsOfAnExistingVM(ctx context.Context, virtualMachineId int, body EditLabelsOfAnExistingVMJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrieveVirtualMachinePerformanceMetrics request
	RetrieveVirtualMachinePerformanceMetrics(ctx context.Context, virtualMachineId int, params *RetrieveVirtualMachinePerformanceMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResizeVirtualMachineWithBody request with any body
	ResizeVirtualMachineWithBody(ctx context.Context, virtualMachineId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResizeVirtualMachine(ctx context.Context, virtualMachineId int, body ResizeVirtualMachineJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddFirewallRuleToVirtualMachineWithBody request with any body
	AddFirewallRuleToVirtualMachineWithBody(ctx context.Context, virtualMachineId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddFirewallRuleToVirtualMachine(ctx context.Context, virtualMachineId int, body AddFirewallRuleToVirtualMachineJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFirewallRuleFromVirtualMachine request
	DeleteFirewallRuleFromVirtualMachine(ctx context.Context, virtualMachineId int, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachFirewallsToAVMWithBody request with any body
	AttachFirewallsToAVMWithBody(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AttachFirewallsToAVM(ctx context.Context, vmId int, body AttachFirewallsToAVMJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListVirtualMachines(ctx context.Context, params *ListVirtualMachinesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListVirtualMachinesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVirtualMachineWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVirtualMachineRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVirtualMachine(ctx context.Context, body CreateVirtualMachineJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVirtualMachineRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrieveVirtualMachinesAssociatedWithAContract(ctx context.Context, contractId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveVirtualMachinesAssociatedWithAContractRequest(c.Server, contractId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVirtualMachine(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVirtualMachineRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrieveVirtualMachineDetails(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveVirtualMachineDetailsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HardRebootVirtualMachine(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHardRebootVirtualMachineRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartVirtualMachine(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartVirtualMachineRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StopVirtualMachine(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopVirtualMachineRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HibernateVirtualMachine(ctx context.Context, virtualMachineId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHibernateVirtualMachineRequest(c.Server, virtualMachineId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreVirtualMachineFromHibernation(ctx context.Context, virtualMachineId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreVirtualMachineFromHibernationRequest(c.Server, virtualMachineId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditLabelsOfAnExistingVMWithBody(ctx context.Context, virtualMachineId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditLabelsOfAnExistingVMRequestWithBody(c.Server, virtualMachineId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditLabelsOfAnExistingVM(ctx context.Context, virtualMachineId int, body EditLabelsOfAnExistingVMJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditLabelsOfAnExistingVMRequest(c.Server, virtualMachineId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrieveVirtualMachinePerformanceMetrics(ctx context.Context, virtualMachineId int, params *RetrieveVirtualMachinePerformanceMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveVirtualMachinePerformanceMetricsRequest(c.Server, virtualMachineId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResizeVirtualMachineWithBody(ctx context.Context, virtualMachineId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResizeVirtualMachineRequestWithBody(c.Server, virtualMachineId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResizeVirtualMachine(ctx context.Context, virtualMachineId int, body ResizeVirtualMachineJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResizeVirtualMachineRequest(c.Server, virtualMachineId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddFirewallRuleToVirtualMachineWithBody(ctx context.Context, virtualMachineId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddFirewallRuleToVirtualMachineRequestWithBody(c.Server, virtualMachineId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddFirewallRuleToVirtualMachine(ctx context.Context, virtualMachineId int, body AddFirewallRuleToVirtualMachineJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddFirewallRuleToVirtualMachineRequest(c.Server, virtualMachineId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFirewallRuleFromVirtualMachine(ctx context.Context, virtualMachineId int, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFirewallRuleFromVirtualMachineRequest(c.Server, virtualMachineId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachFirewallsToAVMWithBody(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachFirewallsToAVMRequestWithBody(c.Server, vmId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachFirewallsToAVM(ctx context.Context, vmId int, body AttachFirewallsToAVMJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachFirewallsToAVMRequest(c.Server, vmId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListVirtualMachinesRequest generates requests for ListVirtualMachines
func NewListVirtualMachinesRequest(server string, params *ListVirtualMachinesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVirtualMachineRequest calls the generic CreateVirtualMachine builder with application/json body
func NewCreateVirtualMachineRequest(server string, body CreateVirtualMachineJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVirtualMachineRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateVirtualMachineRequestWithBody generates requests for CreateVirtualMachine with any type of body
func NewCreateVirtualMachineRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRetrieveVirtualMachinesAssociatedWithAContractRequest generates requests for RetrieveVirtualMachinesAssociatedWithAContract
func NewRetrieveVirtualMachinesAssociatedWithAContractRequest(server string, contractId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "contract_id", runtime.ParamLocationPath, contractId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/contract/%s/virtual-machines", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteVirtualMachineRequest generates requests for DeleteVirtualMachine
func NewDeleteVirtualMachineRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRetrieveVirtualMachineDetailsRequest generates requests for RetrieveVirtualMachineDetails
func NewRetrieveVirtualMachineDetailsRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHardRebootVirtualMachineRequest generates requests for HardRebootVirtualMachine
func NewHardRebootVirtualMachineRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s/hard-reboot", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStartVirtualMachineRequest generates requests for StartVirtualMachine
func NewStartVirtualMachineRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s/start", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStopVirtualMachineRequest generates requests for StopVirtualMachine
func NewStopVirtualMachineRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s/stop", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHibernateVirtualMachineRequest generates requests for HibernateVirtualMachine
func NewHibernateVirtualMachineRequest(server string, virtualMachineId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "virtual_machine_id", runtime.ParamLocationPath, virtualMachineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s/hibernate", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreVirtualMachineFromHibernationRequest generates requests for RestoreVirtualMachineFromHibernation
func NewRestoreVirtualMachineFromHibernationRequest(server string, virtualMachineId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "virtual_machine_id", runtime.ParamLocationPath, virtualMachineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s/hibernate-restore", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEditLabelsOfAnExistingVMRequest calls the generic EditLabelsOfAnExistingVM builder with application/json body
func NewEditLabelsOfAnExistingVMRequest(server string, virtualMachineId int, body EditLabelsOfAnExistingVMJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditLabelsOfAnExistingVMRequestWithBody(server, virtualMachineId, "application/json", bodyReader)
}

// NewEditLabelsOfAnExistingVMRequestWithBody generates requests for EditLabelsOfAnExistingVM with any type of body
func NewEditLabelsOfAnExistingVMRequestWithBody(server string, virtualMachineId int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "virtual_machine_id", runtime.ParamLocationPath, virtualMachineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s/label", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRetrieveVirtualMachinePerformanceMetricsRequest generates requests for RetrieveVirtualMachinePerformanceMetrics
func NewRetrieveVirtualMachinePerformanceMetricsRequest(server string, virtualMachineId int, params *RetrieveVirtualMachinePerformanceMetricsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "virtual_machine_id", runtime.ParamLocationPath, virtualMachineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s/metrics", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Duration != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "duration", runtime.ParamLocationQuery, *params.Duration); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewResizeVirtualMachineRequest calls the generic ResizeVirtualMachine builder with application/json body
func NewResizeVirtualMachineRequest(server string, virtualMachineId int, body ResizeVirtualMachineJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResizeVirtualMachineRequestWithBody(server, virtualMachineId, "application/json", bodyReader)
}

// NewResizeVirtualMachineRequestWithBody generates requests for ResizeVirtualMachine with any type of body
func NewResizeVirtualMachineRequestWithBody(server string, virtualMachineId int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "virtual_machine_id", runtime.ParamLocationPath, virtualMachineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s/resize", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddFirewallRuleToVirtualMachineRequest calls the generic AddFirewallRuleToVirtualMachine builder with application/json body
func NewAddFirewallRuleToVirtualMachineRequest(server string, virtualMachineId int, body AddFirewallRuleToVirtualMachineJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddFirewallRuleToVirtualMachineRequestWithBody(server, virtualMachineId, "application/json", bodyReader)
}

// NewAddFirewallRuleToVirtualMachineRequestWithBody generates requests for AddFirewallRuleToVirtualMachine with any type of body
func NewAddFirewallRuleToVirtualMachineRequestWithBody(server string, virtualMachineId int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "virtual_machine_id", runtime.ParamLocationPath, virtualMachineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s/sg-rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFirewallRuleFromVirtualMachineRequest generates requests for DeleteFirewallRuleFromVirtualMachine
func NewDeleteFirewallRuleFromVirtualMachineRequest(server string, virtualMachineId int, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "virtual_machine_id", runtime.ParamLocationPath, virtualMachineId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s/sg-rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAttachFirewallsToAVMRequest calls the generic AttachFirewallsToAVM builder with application/json body
func NewAttachFirewallsToAVMRequest(server string, vmId int, body AttachFirewallsToAVMJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAttachFirewallsToAVMRequestWithBody(server, vmId, "application/json", bodyReader)
}

// NewAttachFirewallsToAVMRequestWithBody generates requests for AttachFirewallsToAVM with any type of body
func NewAttachFirewallsToAVMRequestWithBody(server string, vmId int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vm_id", runtime.ParamLocationPath, vmId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s/attach-firewalls", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListVirtualMachinesWithResponse request
	ListVirtualMachinesWithResponse(ctx context.Context, params *ListVirtualMachinesParams, reqEditors ...RequestEditorFn) (*ListVirtualMachinesResponse, error)

	// CreateVirtualMachineWithBodyWithResponse request with any body
	CreateVirtualMachineWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVirtualMachineResponse, error)

	CreateVirtualMachineWithResponse(ctx context.Context, body CreateVirtualMachineJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVirtualMachineResponse, error)

	// RetrieveVirtualMachinesAssociatedWithAContractWithResponse request
	RetrieveVirtualMachinesAssociatedWithAContractWithResponse(ctx context.Context, contractId int, reqEditors ...RequestEditorFn) (*RetrieveVirtualMachinesAssociatedWithAContractResponse, error)

	// DeleteVirtualMachineWithResponse request
	DeleteVirtualMachineWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteVirtualMachineResponse, error)

	// RetrieveVirtualMachineDetailsWithResponse request
	RetrieveVirtualMachineDetailsWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*RetrieveVirtualMachineDetailsResponse, error)

	// HardRebootVirtualMachineWithResponse request
	HardRebootVirtualMachineWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*HardRebootVirtualMachineResponse, error)

	// StartVirtualMachineWithResponse request
	StartVirtualMachineWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*StartVirtualMachineResponse, error)

	// StopVirtualMachineWithResponse request
	StopVirtualMachineWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*StopVirtualMachineResponse, error)

	// HibernateVirtualMachineWithResponse request
	HibernateVirtualMachineWithResponse(ctx context.Context, virtualMachineId int, reqEditors ...RequestEditorFn) (*HibernateVirtualMachineResponse, error)

	// RestoreVirtualMachineFromHibernationWithResponse request
	RestoreVirtualMachineFromHibernationWithResponse(ctx context.Context, virtualMachineId int, reqEditors ...RequestEditorFn) (*RestoreVirtualMachineFromHibernationResponse, error)

	// EditLabelsOfAnExistingVMWithBodyWithResponse request with any body
	EditLabelsOfAnExistingVMWithBodyWithResponse(ctx context.Context, virtualMachineId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditLabelsOfAnExistingVMResponse, error)

	EditLabelsOfAnExistingVMWithResponse(ctx context.Context, virtualMachineId int, body EditLabelsOfAnExistingVMJSONRequestBody, reqEditors ...RequestEditorFn) (*EditLabelsOfAnExistingVMResponse, error)

	// RetrieveVirtualMachinePerformanceMetricsWithResponse request
	RetrieveVirtualMachinePerformanceMetricsWithResponse(ctx context.Context, virtualMachineId int, params *RetrieveVirtualMachinePerformanceMetricsParams, reqEditors ...RequestEditorFn) (*RetrieveVirtualMachinePerformanceMetricsResponse, error)

	// ResizeVirtualMachineWithBodyWithResponse request with any body
	ResizeVirtualMachineWithBodyWithResponse(ctx context.Context, virtualMachineId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResizeVirtualMachineResponse, error)

	ResizeVirtualMachineWithResponse(ctx context.Context, virtualMachineId int, body ResizeVirtualMachineJSONRequestBody, reqEditors ...RequestEditorFn) (*ResizeVirtualMachineResponse, error)

	// AddFirewallRuleToVirtualMachineWithBodyWithResponse request with any body
	AddFirewallRuleToVirtualMachineWithBodyWithResponse(ctx context.Context, virtualMachineId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddFirewallRuleToVirtualMachineResponse, error)

	AddFirewallRuleToVirtualMachineWithResponse(ctx context.Context, virtualMachineId int, body AddFirewallRuleToVirtualMachineJSONRequestBody, reqEditors ...RequestEditorFn) (*AddFirewallRuleToVirtualMachineResponse, error)

	// DeleteFirewallRuleFromVirtualMachineWithResponse request
	DeleteFirewallRuleFromVirtualMachineWithResponse(ctx context.Context, virtualMachineId int, id int, reqEditors ...RequestEditorFn) (*DeleteFirewallRuleFromVirtualMachineResponse, error)

	// AttachFirewallsToAVMWithBodyWithResponse request with any body
	AttachFirewallsToAVMWithBodyWithResponse(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachFirewallsToAVMResponse, error)

	AttachFirewallsToAVMWithResponse(ctx context.Context, vmId int, body AttachFirewallsToAVMJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachFirewallsToAVMResponse, error)
}

type ListVirtualMachinesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Instances
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r ListVirtualMachinesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListVirtualMachinesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVirtualMachineResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateInstancesResponse
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
	JSON405      *ErrorResponseModel
	JSON409      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r CreateVirtualMachineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVirtualMachineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrieveVirtualMachinesAssociatedWithAContractResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContractInstancesResponse
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r RetrieveVirtualMachinesAssociatedWithAContractResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveVirtualMachinesAssociatedWithAContractResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVirtualMachineResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseModel
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
	JSON409      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r DeleteVirtualMachineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVirtualMachineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrieveVirtualMachineDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Instance
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r RetrieveVirtualMachineDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveVirtualMachineDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HardRebootVirtualMachineResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseModel
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r HardRebootVirtualMachineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HardRebootVirtualMachineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartVirtualMachineResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseModel
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r StartVirtualMachineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartVirtualMachineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StopVirtualMachineResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseModel
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r StopVirtualMachineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StopVirtualMachineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HibernateVirtualMachineResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseModel
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r HibernateVirtualMachineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HibernateVirtualMachineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreVirtualMachineFromHibernationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseModel
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r RestoreVirtualMachineFromHibernationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreVirtualMachineFromHibernationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditLabelsOfAnExistingVMResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseModel
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
	JSON409      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r EditLabelsOfAnExistingVMResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditLabelsOfAnExistingVMResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrieveVirtualMachinePerformanceMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetricsFields
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
	JSON406      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r RetrieveVirtualMachinePerformanceMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveVirtualMachinePerformanceMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResizeVirtualMachineResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseModel
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
	JSON405      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r ResizeVirtualMachineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResizeVirtualMachineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddFirewallRuleToVirtualMachineResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SecurityGroupRule
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
	JSON409      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r AddFirewallRuleToVirtualMachineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddFirewallRuleToVirtualMachineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFirewallRuleFromVirtualMachineResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseModel
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r DeleteFirewallRuleFromVirtualMachineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFirewallRuleFromVirtualMachineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachFirewallsToAVMResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseModel
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r AttachFirewallsToAVMResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachFirewallsToAVMResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListVirtualMachinesWithResponse request returning *ListVirtualMachinesResponse
func (c *ClientWithResponses) ListVirtualMachinesWithResponse(ctx context.Context, params *ListVirtualMachinesParams, reqEditors ...RequestEditorFn) (*ListVirtualMachinesResponse, error) {
	rsp, err := c.ListVirtualMachines(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListVirtualMachinesResponse(rsp)
}

// CreateVirtualMachineWithBodyWithResponse request with arbitrary body returning *CreateVirtualMachineResponse
func (c *ClientWithResponses) CreateVirtualMachineWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVirtualMachineResponse, error) {
	rsp, err := c.CreateVirtualMachineWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVirtualMachineResponse(rsp)
}

func (c *ClientWithResponses) CreateVirtualMachineWithResponse(ctx context.Context, body CreateVirtualMachineJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVirtualMachineResponse, error) {
	rsp, err := c.CreateVirtualMachine(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVirtualMachineResponse(rsp)
}

// RetrieveVirtualMachinesAssociatedWithAContractWithResponse request returning *RetrieveVirtualMachinesAssociatedWithAContractResponse
func (c *ClientWithResponses) RetrieveVirtualMachinesAssociatedWithAContractWithResponse(ctx context.Context, contractId int, reqEditors ...RequestEditorFn) (*RetrieveVirtualMachinesAssociatedWithAContractResponse, error) {
	rsp, err := c.RetrieveVirtualMachinesAssociatedWithAContract(ctx, contractId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveVirtualMachinesAssociatedWithAContractResponse(rsp)
}

// DeleteVirtualMachineWithResponse request returning *DeleteVirtualMachineResponse
func (c *ClientWithResponses) DeleteVirtualMachineWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteVirtualMachineResponse, error) {
	rsp, err := c.DeleteVirtualMachine(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVirtualMachineResponse(rsp)
}

// RetrieveVirtualMachineDetailsWithResponse request returning *RetrieveVirtualMachineDetailsResponse
func (c *ClientWithResponses) RetrieveVirtualMachineDetailsWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*RetrieveVirtualMachineDetailsResponse, error) {
	rsp, err := c.RetrieveVirtualMachineDetails(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveVirtualMachineDetailsResponse(rsp)
}

// HardRebootVirtualMachineWithResponse request returning *HardRebootVirtualMachineResponse
func (c *ClientWithResponses) HardRebootVirtualMachineWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*HardRebootVirtualMachineResponse, error) {
	rsp, err := c.HardRebootVirtualMachine(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHardRebootVirtualMachineResponse(rsp)
}

// StartVirtualMachineWithResponse request returning *StartVirtualMachineResponse
func (c *ClientWithResponses) StartVirtualMachineWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*StartVirtualMachineResponse, error) {
	rsp, err := c.StartVirtualMachine(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartVirtualMachineResponse(rsp)
}

// StopVirtualMachineWithResponse request returning *StopVirtualMachineResponse
func (c *ClientWithResponses) StopVirtualMachineWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*StopVirtualMachineResponse, error) {
	rsp, err := c.StopVirtualMachine(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStopVirtualMachineResponse(rsp)
}

// HibernateVirtualMachineWithResponse request returning *HibernateVirtualMachineResponse
func (c *ClientWithResponses) HibernateVirtualMachineWithResponse(ctx context.Context, virtualMachineId int, reqEditors ...RequestEditorFn) (*HibernateVirtualMachineResponse, error) {
	rsp, err := c.HibernateVirtualMachine(ctx, virtualMachineId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHibernateVirtualMachineResponse(rsp)
}

// RestoreVirtualMachineFromHibernationWithResponse request returning *RestoreVirtualMachineFromHibernationResponse
func (c *ClientWithResponses) RestoreVirtualMachineFromHibernationWithResponse(ctx context.Context, virtualMachineId int, reqEditors ...RequestEditorFn) (*RestoreVirtualMachineFromHibernationResponse, error) {
	rsp, err := c.RestoreVirtualMachineFromHibernation(ctx, virtualMachineId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreVirtualMachineFromHibernationResponse(rsp)
}

// EditLabelsOfAnExistingVMWithBodyWithResponse request with arbitrary body returning *EditLabelsOfAnExistingVMResponse
func (c *ClientWithResponses) EditLabelsOfAnExistingVMWithBodyWithResponse(ctx context.Context, virtualMachineId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditLabelsOfAnExistingVMResponse, error) {
	rsp, err := c.EditLabelsOfAnExistingVMWithBody(ctx, virtualMachineId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditLabelsOfAnExistingVMResponse(rsp)
}

func (c *ClientWithResponses) EditLabelsOfAnExistingVMWithResponse(ctx context.Context, virtualMachineId int, body EditLabelsOfAnExistingVMJSONRequestBody, reqEditors ...RequestEditorFn) (*EditLabelsOfAnExistingVMResponse, error) {
	rsp, err := c.EditLabelsOfAnExistingVM(ctx, virtualMachineId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditLabelsOfAnExistingVMResponse(rsp)
}

// RetrieveVirtualMachinePerformanceMetricsWithResponse request returning *RetrieveVirtualMachinePerformanceMetricsResponse
func (c *ClientWithResponses) RetrieveVirtualMachinePerformanceMetricsWithResponse(ctx context.Context, virtualMachineId int, params *RetrieveVirtualMachinePerformanceMetricsParams, reqEditors ...RequestEditorFn) (*RetrieveVirtualMachinePerformanceMetricsResponse, error) {
	rsp, err := c.RetrieveVirtualMachinePerformanceMetrics(ctx, virtualMachineId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveVirtualMachinePerformanceMetricsResponse(rsp)
}

// ResizeVirtualMachineWithBodyWithResponse request with arbitrary body returning *ResizeVirtualMachineResponse
func (c *ClientWithResponses) ResizeVirtualMachineWithBodyWithResponse(ctx context.Context, virtualMachineId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResizeVirtualMachineResponse, error) {
	rsp, err := c.ResizeVirtualMachineWithBody(ctx, virtualMachineId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResizeVirtualMachineResponse(rsp)
}

func (c *ClientWithResponses) ResizeVirtualMachineWithResponse(ctx context.Context, virtualMachineId int, body ResizeVirtualMachineJSONRequestBody, reqEditors ...RequestEditorFn) (*ResizeVirtualMachineResponse, error) {
	rsp, err := c.ResizeVirtualMachine(ctx, virtualMachineId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResizeVirtualMachineResponse(rsp)
}

// AddFirewallRuleToVirtualMachineWithBodyWithResponse request with arbitrary body returning *AddFirewallRuleToVirtualMachineResponse
func (c *ClientWithResponses) AddFirewallRuleToVirtualMachineWithBodyWithResponse(ctx context.Context, virtualMachineId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddFirewallRuleToVirtualMachineResponse, error) {
	rsp, err := c.AddFirewallRuleToVirtualMachineWithBody(ctx, virtualMachineId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddFirewallRuleToVirtualMachineResponse(rsp)
}

func (c *ClientWithResponses) AddFirewallRuleToVirtualMachineWithResponse(ctx context.Context, virtualMachineId int, body AddFirewallRuleToVirtualMachineJSONRequestBody, reqEditors ...RequestEditorFn) (*AddFirewallRuleToVirtualMachineResponse, error) {
	rsp, err := c.AddFirewallRuleToVirtualMachine(ctx, virtualMachineId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddFirewallRuleToVirtualMachineResponse(rsp)
}

// DeleteFirewallRuleFromVirtualMachineWithResponse request returning *DeleteFirewallRuleFromVirtualMachineResponse
func (c *ClientWithResponses) DeleteFirewallRuleFromVirtualMachineWithResponse(ctx context.Context, virtualMachineId int, id int, reqEditors ...RequestEditorFn) (*DeleteFirewallRuleFromVirtualMachineResponse, error) {
	rsp, err := c.DeleteFirewallRuleFromVirtualMachine(ctx, virtualMachineId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFirewallRuleFromVirtualMachineResponse(rsp)
}

// AttachFirewallsToAVMWithBodyWithResponse request with arbitrary body returning *AttachFirewallsToAVMResponse
func (c *ClientWithResponses) AttachFirewallsToAVMWithBodyWithResponse(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachFirewallsToAVMResponse, error) {
	rsp, err := c.AttachFirewallsToAVMWithBody(ctx, vmId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachFirewallsToAVMResponse(rsp)
}

func (c *ClientWithResponses) AttachFirewallsToAVMWithResponse(ctx context.Context, vmId int, body AttachFirewallsToAVMJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachFirewallsToAVMResponse, error) {
	rsp, err := c.AttachFirewallsToAVM(ctx, vmId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachFirewallsToAVMResponse(rsp)
}

// ParseListVirtualMachinesResponse parses an HTTP response from a ListVirtualMachinesWithResponse call
func ParseListVirtualMachinesResponse(rsp *http.Response) (*ListVirtualMachinesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListVirtualMachinesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Instances
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateVirtualMachineResponse parses an HTTP response from a CreateVirtualMachineWithResponse call
func ParseCreateVirtualMachineResponse(rsp *http.Response) (*CreateVirtualMachineResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVirtualMachineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateInstancesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseRetrieveVirtualMachinesAssociatedWithAContractResponse parses an HTTP response from a RetrieveVirtualMachinesAssociatedWithAContractWithResponse call
func ParseRetrieveVirtualMachinesAssociatedWithAContractResponse(rsp *http.Response) (*RetrieveVirtualMachinesAssociatedWithAContractResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveVirtualMachinesAssociatedWithAContractResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContractInstancesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteVirtualMachineResponse parses an HTTP response from a DeleteVirtualMachineWithResponse call
func ParseDeleteVirtualMachineResponse(rsp *http.Response) (*DeleteVirtualMachineResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVirtualMachineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseRetrieveVirtualMachineDetailsResponse parses an HTTP response from a RetrieveVirtualMachineDetailsWithResponse call
func ParseRetrieveVirtualMachineDetailsResponse(rsp *http.Response) (*RetrieveVirtualMachineDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveVirtualMachineDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Instance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseHardRebootVirtualMachineResponse parses an HTTP response from a HardRebootVirtualMachineWithResponse call
func ParseHardRebootVirtualMachineResponse(rsp *http.Response) (*HardRebootVirtualMachineResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HardRebootVirtualMachineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseStartVirtualMachineResponse parses an HTTP response from a StartVirtualMachineWithResponse call
func ParseStartVirtualMachineResponse(rsp *http.Response) (*StartVirtualMachineResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartVirtualMachineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseStopVirtualMachineResponse parses an HTTP response from a StopVirtualMachineWithResponse call
func ParseStopVirtualMachineResponse(rsp *http.Response) (*StopVirtualMachineResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StopVirtualMachineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseHibernateVirtualMachineResponse parses an HTTP response from a HibernateVirtualMachineWithResponse call
func ParseHibernateVirtualMachineResponse(rsp *http.Response) (*HibernateVirtualMachineResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HibernateVirtualMachineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseRestoreVirtualMachineFromHibernationResponse parses an HTTP response from a RestoreVirtualMachineFromHibernationWithResponse call
func ParseRestoreVirtualMachineFromHibernationResponse(rsp *http.Response) (*RestoreVirtualMachineFromHibernationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreVirtualMachineFromHibernationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseEditLabelsOfAnExistingVMResponse parses an HTTP response from a EditLabelsOfAnExistingVMWithResponse call
func ParseEditLabelsOfAnExistingVMResponse(rsp *http.Response) (*EditLabelsOfAnExistingVMResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditLabelsOfAnExistingVMResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseRetrieveVirtualMachinePerformanceMetricsResponse parses an HTTP response from a RetrieveVirtualMachinePerformanceMetricsWithResponse call
func ParseRetrieveVirtualMachinePerformanceMetricsResponse(rsp *http.Response) (*RetrieveVirtualMachinePerformanceMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveVirtualMachinePerformanceMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetricsFields
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseResizeVirtualMachineResponse parses an HTTP response from a ResizeVirtualMachineWithResponse call
func ParseResizeVirtualMachineResponse(rsp *http.Response) (*ResizeVirtualMachineResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResizeVirtualMachineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseAddFirewallRuleToVirtualMachineResponse parses an HTTP response from a AddFirewallRuleToVirtualMachineWithResponse call
func ParseAddFirewallRuleToVirtualMachineResponse(rsp *http.Response) (*AddFirewallRuleToVirtualMachineResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddFirewallRuleToVirtualMachineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SecurityGroupRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseDeleteFirewallRuleFromVirtualMachineResponse parses an HTTP response from a DeleteFirewallRuleFromVirtualMachineWithResponse call
func ParseDeleteFirewallRuleFromVirtualMachineResponse(rsp *http.Response) (*DeleteFirewallRuleFromVirtualMachineResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFirewallRuleFromVirtualMachineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAttachFirewallsToAVMResponse parses an HTTP response from a AttachFirewallsToAVMWithResponse call
func ParseAttachFirewallsToAVMResponse(rsp *http.Response) (*AttachFirewallsToAVMResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachFirewallsToAVMResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}
