// Package virtual_machine provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.2.0 DO NOT EDIT.
package virtual_machine

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"github.com/NexGenCloud/hyperstack-sdk-go/lib/time"

	"github.com/oapi-codegen/runtime"
)

// Defines values for CreateSecurityRulePayloadProtocol.
const (
	Ah        CreateSecurityRulePayloadProtocol = "ah"
	Any       CreateSecurityRulePayloadProtocol = "any"
	Dccp      CreateSecurityRulePayloadProtocol = "dccp"
	Egp       CreateSecurityRulePayloadProtocol = "egp"
	Esp       CreateSecurityRulePayloadProtocol = "esp"
	Gre       CreateSecurityRulePayloadProtocol = "gre"
	Hopopt    CreateSecurityRulePayloadProtocol = "hopopt"
	Icmp      CreateSecurityRulePayloadProtocol = "icmp"
	Icmpv6    CreateSecurityRulePayloadProtocol = "icmpv6"
	Igmp      CreateSecurityRulePayloadProtocol = "igmp"
	Ip        CreateSecurityRulePayloadProtocol = "ip"
	Ipip      CreateSecurityRulePayloadProtocol = "ipip"
	Ipv6Encap CreateSecurityRulePayloadProtocol = "ipv6-encap"
	Ipv6Frag  CreateSecurityRulePayloadProtocol = "ipv6-frag"
	Ipv6Icmp  CreateSecurityRulePayloadProtocol = "ipv6-icmp"
	Ipv6Nonxt CreateSecurityRulePayloadProtocol = "ipv6-nonxt"
	Ipv6Opts  CreateSecurityRulePayloadProtocol = "ipv6-opts"
	Ipv6Route CreateSecurityRulePayloadProtocol = "ipv6-route"
	Ospf      CreateSecurityRulePayloadProtocol = "ospf"
	Pgm       CreateSecurityRulePayloadProtocol = "pgm"
	Rsvp      CreateSecurityRulePayloadProtocol = "rsvp"
	Sctp      CreateSecurityRulePayloadProtocol = "sctp"
	Tcp       CreateSecurityRulePayloadProtocol = "tcp"
	Udp       CreateSecurityRulePayloadProtocol = "udp"
	Udplite   CreateSecurityRulePayloadProtocol = "udplite"
	Vrrp      CreateSecurityRulePayloadProtocol = "vrrp"
)

// Defines values for EnvironmentFeaturesGreenStatus.
const (
	GREEN          EnvironmentFeaturesGreenStatus = "GREEN"
	NOTGREEN       EnvironmentFeaturesGreenStatus = "NOT_GREEN"
	PARTIALLYGREEN EnvironmentFeaturesGreenStatus = "PARTIALLY_GREEN"
)

// AttachFirewallsToVMPayload defines model for AttachFirewallsToVMPayload.
type AttachFirewallsToVMPayload struct {
	// Firewalls Ids of the firewalls to be attached with a virtual machine.
	Firewalls []int `json:"firewalls"`
}

// ClusterFields defines model for ClusterFields.
type ClusterFields struct {
	ApiAddress        *string                   `json:"api_address,omitempty"`
	CreatedAt         *time.CustomTime                `json:"created_at,omitempty"`
	EnvironmentName   *string                   `json:"environment_name,omitempty"`
	Id                *int                      `json:"id,omitempty"`
	KeypairName       *string                   `json:"keypair_name,omitempty"`
	KubeConfig        *string                   `json:"kube_config,omitempty"`
	KubernetesVersion *string                   `json:"kubernetes_version,omitempty"`
	MasterFlavor      *ClusterFlavorFields      `json:"master_flavor,omitempty"`
	Name              *string                   `json:"name,omitempty"`
	NodeGroups        *[]ClusterNodeGroupFields `json:"node_groups,omitempty"`
	Nodes             *[]ClusterNodeFields      `json:"nodes,omitempty"`
	Status            *string                   `json:"status,omitempty"`
	StatusReason      *string                   `json:"status_reason,omitempty"`
}

// ClusterNodeFields defines model for ClusterNodeFields.
type ClusterNodeFields struct {
	CreatedAt        *time.CustomTime                 `json:"created_at,omitempty"`
	Id               *int                       `json:"id,omitempty"`
	Instance         *ClusterNodeInstanceFields `json:"instance,omitempty"`
	IsBastion        *bool                      `json:"is_bastion,omitempty"`
	NodeGroupId      *int                       `json:"node_group_id,omitempty"`
	NodeGroupName    *string                    `json:"node_group_name,omitempty"`
	RequiresPublicIp *bool                      `json:"requires_public_ip,omitempty"`
	Role             *string                    `json:"role,omitempty"`
	Status           *string                    `json:"status,omitempty"`
	StatusReason     *string                    `json:"status_reason,omitempty"`
	UpdatedAt        *time.CustomTime                 `json:"updated_at,omitempty"`
}

// ClusterNodeGroupFields defines model for ClusterNodeGroupFields.
type ClusterNodeGroupFields struct {
	Count     *int                 `json:"count,omitempty"`
	CreatedAt *time.CustomTime           `json:"created_at,omitempty"`
	Flavor    *ClusterFlavorFields `json:"flavor,omitempty"`
	Id        *int                 `json:"id,omitempty"`
	Name      *string              `json:"name,omitempty"`
	Role      *string              `json:"role,omitempty"`
	UpdatedAt *time.CustomTime           `json:"updated_at,omitempty"`
}

// ClusterNodeInstanceFields defines model for ClusterNodeInstanceFields.
type ClusterNodeInstanceFields struct {
	ContractId       *int    `json:"contract_id,omitempty"`
	FixedIp          *string `json:"fixed_ip,omitempty"`
	FloatingIp       *string `json:"floating_ip,omitempty"`
	FloatingIpStatus *string `json:"floating_ip_status,omitempty"`
	Id               *int    `json:"id,omitempty"`
	ImageId          *int    `json:"image_id,omitempty"`
	Name             *string `json:"name,omitempty"`
	Status           *string `json:"status,omitempty"`
}

// ClusterFlavorFields defines model for Cluster_Flavor_Fields.
type ClusterFlavorFields struct {
	Cpu       *int                    `json:"cpu,omitempty"`
	Disk      *int                    `json:"disk,omitempty"`
	Ephemeral *int                    `json:"ephemeral,omitempty"`
	Features  *map[string]interface{} `json:"features,omitempty"`
	Gpu       *string                 `json:"gpu,omitempty"`
	GpuCount  *int                    `json:"gpu_count,omitempty"`
	Id        *int                    `json:"id,omitempty"`
	Labels    *[]LableResonse         `json:"labels,omitempty"`
	Name      *string                 `json:"name,omitempty"`
	Ram       *float32                `json:"ram,omitempty"`
}

// ContractInstanceFields defines model for ContractInstanceFields.
type ContractInstanceFields struct {
	Cluster         *ClusterFields `json:"cluster,omitempty"`
	CreatedAt       *time.CustomTime     `json:"created_at,omitempty"`
	FlavorName      *string        `json:"flavor_name,omitempty"`
	GpuCount        *int           `json:"gpu_count,omitempty"`
	Id              *int           `json:"id,omitempty"`
	Name            *string        `json:"name,omitempty"`
	Status          *string        `json:"status,omitempty"`
	TerminationTime *time.CustomTime     `json:"termination_time,omitempty"`
	TotalUsageTime  *int           `json:"total_usage_time,omitempty"`
}

// ContractInstancesResponse defines model for ContractInstancesResponse.
type ContractInstancesResponse struct {
	Instances *[]ContractInstanceFields `json:"instances,omitempty"`
	Message   *string                   `json:"message,omitempty"`
	Status    *bool                     `json:"status,omitempty"`
}

// CreateInstancesResponse defines model for CreateInstancesResponse.
type CreateInstancesResponse struct {
	Instances *[]InstanceFields `json:"instances,omitempty"`
	Message   *string           `json:"message,omitempty"`
	Status    *bool             `json:"status,omitempty"`
}

// CreateSnapshotPayload defines model for CreateSnapshotPayload.
type CreateSnapshotPayload struct {
	// Description description
	Description string `json:"description"`

	// Labels Labels associated with snapshot
	Labels *[]string `json:"labels,omitempty"`

	// Name Snapshot name
	Name string `json:"name"`
}

// CreateSnapshotResponse defines model for CreateSnapshotResponse.
type CreateSnapshotResponse struct {
	Message  *string         `json:"message,omitempty"`
	Snapshot *SnapshotFields `json:"snapshot,omitempty"`
	Status   *bool           `json:"status,omitempty"`
}

// CreateInstancesPayload defines model for Create_Instances_Payload.
type CreateInstancesPayload struct {
	// AssignFloatingIp When this field is set to `true`, it attaches a [public IP address](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/floating-ip/) to the virtual machine, enabling internet accessibility.
	AssignFloatingIp *bool `json:"assign_floating_ip,omitempty"`

	// CallbackUrl An optional URL where actions performed on the virtual machine will be sent. For additional information on event callbacks, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/callbacks-vms/).
	CallbackUrl *string `json:"callback_url,omitempty"`

	// Count The number of virtual machines to be created.
	Count int `json:"count"`

	// CreateBootableVolume Indicates whether to create a bootable volume for the virtual machine. When set to `true`, a bootable volume will be created; the default value is `false`.
	CreateBootableVolume *bool `json:"create_bootable_volume,omitempty"`

	// EnablePortRandomization Indicates whether to enable port randomization.This setting is only effective if 'assign_floating_ip' is true. Defaults to true.
	EnablePortRandomization *bool `json:"enable_port_randomization,omitempty"`

	// EnvironmentName The name of the [environment](https://docs.hyperstack.cloud/docs/api-reference/core-resources/environments/) in which the virtual machine is to be created.
	EnvironmentName string              `json:"environment_name"`
	Flavor          *FlavorObjectFields `json:"flavor,omitempty"`

	// FlavorName The name of the GPU hardware configuration ([flavor](https://docs.hyperstack.cloud/docs/hardware/flavors)) for the virtual machines being created.
	FlavorName string `json:"flavor_name"`

	// ImageName The [operating system (OS) image](https://docs.hyperstack.cloud/docs/virtual-machines/images) name designated for installation on the virtual machine.It also accepts custom, private images, created from [existing snapshots](https://docs.hyperstack.cloud/docs/virtual-machines/custom-images).
	ImageName *string `json:"image_name,omitempty"`

	// KeyName The name of the existing SSH key pair to be used for secure access to the virtual machine. For additional information on SSH key pairs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/keypairs/).
	KeyName string    `json:"key_name"`
	Labels  *[]string `json:"labels,omitempty"`

	// Name The name of the virtual machine being created.
	Name          string                       `json:"name"`
	Profile       *ProfileObjectFields         `json:"profile,omitempty"`
	SecurityRules *[]CreateSecurityRulePayload `json:"security_rules,omitempty"`

	// UserData Optional initialization configuration commands to manage the configuration of a virtual machine at launch using cloud-init scripts. For more information about custom VM configuration using cloud-init, [**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/initialization-configuration).
	UserData *string `json:"user_data,omitempty"`

	// VolumeName The names of the volume(s) to be attached to the virtual machine being created.
	VolumeName *string `json:"volume_name,omitempty"`
}

// CreateSecurityRulePayload defines model for Create_Security_Rule_Payload.
type CreateSecurityRulePayload struct {
	// Direction The direction of traffic that the firewall rule applies to.
	Direction string `json:"direction"`

	// Ethertype The Ethernet type associated with the rule.
	Ethertype    string `json:"ethertype"`
	PortRangeMax *int   `json:"port_range_max,omitempty"`
	PortRangeMin *int   `json:"port_range_min,omitempty"`

	// Protocol The network protocol associated with the rule. Call the [`GET /core/sg-rules-protocols`](https://infrahub-api-doc.nexgencloud.com/#get-/core/sg-rules-protocols) endpoint to retrieve a list of permitted network protocols.
	Protocol CreateSecurityRulePayloadProtocol `json:"protocol"`

	// RemoteIpPrefix The IP address range that is allowed to access the specified port. Use "0.0.0.0/0" to allow any IP address.
	RemoteIpPrefix string `json:"remote_ip_prefix"`
}

// CreateSecurityRulePayloadProtocol The network protocol associated with the rule. Call the [`GET /core/sg-rules-protocols`](https://infrahub-api-doc.nexgencloud.com/#get-/core/sg-rules-protocols) endpoint to retrieve a list of permitted network protocols.
type CreateSecurityRulePayloadProtocol string

// EditLabelOfAnExistingVMPayload defines model for Edit_label_of_an_existing_VM_Payload.
type EditLabelOfAnExistingVMPayload struct {
	// Labels Multiple labels can be added by separating with spaces
	Labels *[]string `json:"labels,omitempty"`
}

// EnvironmentFeatures defines model for Environment_Features.
type EnvironmentFeatures struct {
	GreenStatus      *EnvironmentFeaturesGreenStatus `json:"green_status,omitempty"`
	NetworkOptimised *bool                           `json:"network_optimised,omitempty"`
}

// EnvironmentFeaturesGreenStatus defines model for EnvironmentFeatures.GreenStatus.
type EnvironmentFeaturesGreenStatus string

// ErrorResponseModel defines model for ErrorResponseModel.
type ErrorResponseModel struct {
	ErrorReason *string `json:"error_reason,omitempty"`
	Message     *string `json:"message,omitempty"`
	Status      *bool   `json:"status,omitempty"`
}

// FlavorLabelFields defines model for FlavorLabelFields.
type FlavorLabelFields struct {
	Id    *int    `json:"id,omitempty"`
	Label *string `json:"label,omitempty"`
}

// FlavorObjectFields defines model for Flavor_Object_Fields.
type FlavorObjectFields struct {
	Cpu      *int     `json:"cpu,omitempty"`
	Disk     *int     `json:"disk,omitempty"`
	Gpu      *string  `json:"gpu,omitempty"`
	GpuCount *int     `json:"gpu_count,omitempty"`
	Ram      *float32 `json:"ram,omitempty"`
}

// GetInstanceLogsData defines model for GetInstanceLogsData.
type GetInstanceLogsData struct {
	Logs *string `json:"logs,omitempty"`
}

// Instance defines model for Instance.
type Instance struct {
	Instance *InstanceFields `json:"instance,omitempty"`
	Message  *string         `json:"message,omitempty"`
	Status   *bool           `json:"status,omitempty"`
}

// InstanceResizePayload defines model for InstanceResizePayload.
type InstanceResizePayload struct {
	Flavor     *FlavorObjectFields `json:"flavor,omitempty"`
	FlavorName *string             `json:"flavor_name,omitempty"`
}

// InstanceEnvironmentFields defines model for Instance_Environment_Fields.
type InstanceEnvironmentFields struct {
	Features *EnvironmentFeatures `json:"features,omitempty"`
	Id       *int                 `json:"id,omitempty"`
	Name     *string              `json:"name,omitempty"`
	OrgId    *int                 `json:"org_id,omitempty"`
	Region   *string              `json:"region,omitempty"`
}

// InstanceFields defines model for Instance_Fields.
type InstanceFields struct {
	CallbackUrl             *string                           `json:"callback_url,omitempty"`
	ContractId              *int                              `json:"contract_id,omitempty"`
	CreatedAt               *time.CustomTime                        `json:"created_at,omitempty"`
	Environment             *InstanceEnvironmentFields        `json:"environment,omitempty"`
	Features                *map[string]interface{}           `json:"features,omitempty"`
	FixedIp                 *string                           `json:"fixed_ip,omitempty"`
	Flavor                  *InstanceFlavorFields             `json:"flavor,omitempty"`
	FloatingIp              *string                           `json:"floating_ip,omitempty"`
	FloatingIpStatus        *string                           `json:"floating_ip_status,omitempty"`
	Id                      *int                              `json:"id,omitempty"`
	Image                   *InstanceImageFields              `json:"image,omitempty"`
	Keypair                 *InstanceKeypairFields            `json:"keypair,omitempty"`
	Labels                  *[]string                         `json:"labels,omitempty"`
	Locked                  *bool                             `json:"locked,omitempty"`
	Name                    *string                           `json:"name,omitempty"`
	Os                      *string                           `json:"os,omitempty"`
	PortRandomization       *bool                             `json:"port_randomization,omitempty"`
	PortRandomizationStatus *string                           `json:"port_randomization_status,omitempty"`
	PowerState              *string                           `json:"power_state,omitempty"`
	RequiresPublicIp        *bool                             `json:"requires_public_ip,omitempty"`
	SecurityRules           *[]SecurityRulesFieldsForInstance `json:"security_rules,omitempty"`
	Status                  *string                           `json:"status,omitempty"`
	VmState                 *string                           `json:"vm_state,omitempty"`
	VolumeAttachments       *[]VolumeAttachmentFields         `json:"volume_attachments,omitempty"`
}

// InstanceFlavorFields defines model for Instance_Flavor_Fields.
type InstanceFlavorFields struct {
	Cpu       *int                    `json:"cpu,omitempty"`
	Disk      *int                    `json:"disk,omitempty"`
	Ephemeral *int                    `json:"ephemeral,omitempty"`
	Features  *map[string]interface{} `json:"features,omitempty"`
	Gpu       *string                 `json:"gpu,omitempty"`
	GpuCount  *int                    `json:"gpu_count,omitempty"`
	Id        *int                    `json:"id,omitempty"`
	Labels    *[]FlavorLabelFields    `json:"labels,omitempty"`
	Name      *string                 `json:"name,omitempty"`
	Ram       *float32                `json:"ram,omitempty"`
}

// InstanceImageFields defines model for Instance_Image_Fields.
type InstanceImageFields struct {
	Name *string `json:"name,omitempty"`
}

// InstanceKeypairFields defines model for Instance_Keypair_Fields.
type InstanceKeypairFields struct {
	Name *string `json:"name,omitempty"`
}

// Instances defines model for Instances.
type Instances struct {
	Count     *int              `json:"count,omitempty"`
	Instances *[]InstanceFields `json:"instances,omitempty"`
	Message   *string           `json:"message,omitempty"`
	Page      *int              `json:"page,omitempty"`
	PageSize  *int              `json:"page_size,omitempty"`
	Status    *bool             `json:"status,omitempty"`
}

// LableResonse defines model for LableResonse.
type LableResonse struct {
	Id    *int    `json:"id,omitempty"`
	Label *string `json:"label,omitempty"`
}

// MetricItemFields defines model for MetricItemFields.
type MetricItemFields struct {
	Columns *[]string                   `json:"columns,omitempty"`
	Data    *[][]map[string]interface{} `json:"data,omitempty"`
	Unit    *string                     `json:"unit,omitempty"`
}

// MetricsFields defines model for MetricsFields.
type MetricsFields struct {
	Cpu          *MetricItemFields `json:"cpu,omitempty"`
	DiskRead     *MetricItemFields `json:"disk.read,omitempty"`
	DiskWrite    *MetricItemFields `json:"disk.write,omitempty"`
	MemoryUsages *MetricItemFields `json:"memory.usages,omitempty"`
	NetworkIn    *MetricItemFields `json:"network.in,omitempty"`
	NetworkOut   *MetricItemFields `json:"network.out,omitempty"`
}

// NameAvailableModel defines model for NameAvailableModel.
type NameAvailableModel struct {
	Available *bool   `json:"available,omitempty"`
	Message   *string `json:"message,omitempty"`
	Name      *string `json:"name,omitempty"`
}

// ProfileObjectFields defines model for Profile_Object_Fields.
type ProfileObjectFields struct {
	Description *string `json:"description,omitempty"`
	Name        string  `json:"name"`
}

// RequestInstanceLogsPayload defines model for RequestInstanceLogsPayload.
type RequestInstanceLogsPayload struct {
	// Length The amount of lines to fetch
	Length *int `json:"length,omitempty"`
}

// RequestInstanceLogsResponse defines model for RequestInstanceLogsResponse.
type RequestInstanceLogsResponse struct {
	RequestId *int `json:"request_id,omitempty"`
}

// ResponseModel defines model for ResponseModel.
type ResponseModel struct {
	Message *string `json:"message,omitempty"`
	Status  *bool   `json:"status,omitempty"`
}

// SecurityGroupRule defines model for Security_Group_Rule.
type SecurityGroupRule struct {
	Message      *string                  `json:"message,omitempty"`
	SecurityRule *SecurityGroupRuleFields `json:"security_rule,omitempty"`
	Status       *bool                    `json:"status,omitempty"`
}

// SecurityGroupRuleFields defines model for Security_Group_Rule_Fields.
type SecurityGroupRuleFields struct {
	CreatedAt      *time.CustomTime `json:"created_at,omitempty"`
	Direction      *string    `json:"direction,omitempty"`
	Ethertype      *string    `json:"ethertype,omitempty"`
	Id             *int       `json:"id,omitempty"`
	PortRangeMax   *int       `json:"port_range_max,omitempty"`
	PortRangeMin   *int       `json:"port_range_min,omitempty"`
	Protocol       *string    `json:"protocol,omitempty"`
	RemoteIpPrefix *string    `json:"remote_ip_prefix,omitempty"`
	Status         *string    `json:"status,omitempty"`
}

// SecurityRulesFieldsForInstance defines model for Security_Rules_Fields_for_Instance.
type SecurityRulesFieldsForInstance struct {
	CreatedAt      *time.CustomTime `json:"created_at,omitempty"`
	Direction      *string    `json:"direction,omitempty"`
	Ethertype      *string    `json:"ethertype,omitempty"`
	Id             *int       `json:"id,omitempty"`
	PortRangeMax   *int       `json:"port_range_max,omitempty"`
	PortRangeMin   *int       `json:"port_range_min,omitempty"`
	Protocol       *string    `json:"protocol,omitempty"`
	RemoteIpPrefix *string    `json:"remote_ip_prefix,omitempty"`
	Status         *string    `json:"status,omitempty"`
}

// SnapshotFields defines model for SnapshotFields.
type SnapshotFields struct {
	// CreatedAt Creation timestamp
	CreatedAt time.CustomTime `json:"created_at"`

	// Description Description of the snapshot
	Description string `json:"description"`

	// HasFloatingIp Indicates if the VM had a floating IP assigned
	HasFloatingIp *bool `json:"has_floating_ip,omitempty"`

	// Id Snapshot ID
	Id int `json:"id"`

	// IsImage Indicates if the snapshot is an image
	IsImage bool `json:"is_image"`

	// Labels Labels associated with snapshot
	Labels *[]string `json:"labels,omitempty"`

	// Name Snapshot name
	Name string `json:"name"`

	// RegionId Region where the snapshot will be available
	RegionId int `json:"region_id"`

	// Size Size in GB of the snapshot
	Size int `json:"size"`

	// Status Status of the snapshot
	Status string `json:"status"`

	// UpdatedAt Last update timestamp
	UpdatedAt time.CustomTime `json:"updated_at"`

	// VmId ID of the VM from which the snapshot is created
	VmId int `json:"vm_id"`
}

// VolumeAttachmentFields defines model for Volume_Attachment_Fields.
type VolumeAttachmentFields struct {
	CreatedAt *time.CustomTime               `json:"created_at,omitempty"`
	Device    *string                  `json:"device,omitempty"`
	Id        *int                     `json:"id,omitempty"`
	Protected *bool                    `json:"protected,omitempty"`
	Status    *string                  `json:"status,omitempty"`
	Volume    *VolumeFieldsForInstance `json:"volume,omitempty"`
}

// VolumeFieldsForInstance defines model for Volume_Fields_for_Instance.
type VolumeFieldsForInstance struct {
	Bootable    *bool   `json:"bootable,omitempty"`
	Description *string `json:"description,omitempty"`
	Id          *int    `json:"id,omitempty"`
	Name        *string `json:"name,omitempty"`
	Size        *int    `json:"size,omitempty"`
	VolumeType  *string `json:"volume_type,omitempty"`
}

// GetInstanceParams defines parameters for GetInstance.
type GetInstanceParams struct {
	Page             *int           `form:"page,omitempty" json:"page,omitempty"`
	PageSize         *int           `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	Search           *string        `form:"search,omitempty" json:"search,omitempty"`
	Environment      *string        `form:"environment,omitempty" json:"environment,omitempty"`
	ExcludeFirewalls *[]interface{} `form:"exclude_firewalls,omitempty" json:"exclude_firewalls,omitempty"`
}

// GetContractInstancesParams defines parameters for GetContractInstances.
type GetContractInstancesParams struct {
	Page     *string `form:"page,omitempty" json:"page,omitempty"`
	PageSize *string `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	Search   *string `form:"search,omitempty" json:"search,omitempty"`
}

// GetInstanceLogsParams defines parameters for GetInstanceLogs.
type GetInstanceLogsParams struct {
	RequestId int `form:"request_id" json:"request_id"`
}

// GetInstanceMetricsParams defines parameters for GetInstanceMetrics.
type GetInstanceMetricsParams struct {
	Duration *string `form:"duration,omitempty" json:"duration,omitempty"`
}

// PostInstanceJSONRequestBody defines body for PostInstance for application/json ContentType.
type PostInstanceJSONRequestBody = CreateInstancesPayload

// PostInstanceAttachFirewallsJSONRequestBody defines body for PostInstanceAttachFirewalls for application/json ContentType.
type PostInstanceAttachFirewallsJSONRequestBody = AttachFirewallsToVMPayload

// PutLabelsJSONRequestBody defines body for PutLabels for application/json ContentType.
type PutLabelsJSONRequestBody = EditLabelOfAnExistingVMPayload

// PostInstanceLogsJSONRequestBody defines body for PostInstanceLogs for application/json ContentType.
type PostInstanceLogsJSONRequestBody = RequestInstanceLogsPayload

// PostInstanceResizeJSONRequestBody defines body for PostInstanceResize for application/json ContentType.
type PostInstanceResizeJSONRequestBody = InstanceResizePayload

// PostSecurityRuleJSONRequestBody defines body for PostSecurityRule for application/json ContentType.
type PostSecurityRuleJSONRequestBody = CreateSecurityRulePayload

// PostSnapshotsJSONRequestBody defines body for PostSnapshots for application/json ContentType.
type PostSnapshotsJSONRequestBody = CreateSnapshotPayload

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetInstance request
	GetInstance(ctx context.Context, params *GetInstanceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostInstanceWithBody request with any body
	PostInstanceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostInstance(ctx context.Context, body PostInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetContractInstances request
	GetContractInstances(ctx context.Context, contractId int, params *GetContractInstancesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FetchVirtualMachineNameAvailability request
	FetchVirtualMachineNameAvailability(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteInstance request
	DeleteInstance(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInstance2 request
	GetInstance2(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostInstanceAttachFirewallsWithBody request with any body
	PostInstanceAttachFirewallsWithBody(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostInstanceAttachFirewalls(ctx context.Context, vmId int, body PostInstanceAttachFirewallsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInstance3 request
	GetInstance3(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInstanceHibernate request
	GetInstanceHibernate(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInstanceHibernateRestore request
	GetInstanceHibernateRestore(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutLabelsWithBody request with any body
	PutLabelsWithBody(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutLabels(ctx context.Context, vmId int, body PutLabelsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInstanceLogs request
	GetInstanceLogs(ctx context.Context, vmId int, params *GetInstanceLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostInstanceLogsWithBody request with any body
	PostInstanceLogsWithBody(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostInstanceLogs(ctx context.Context, vmId int, body PostInstanceLogsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInstanceMetrics request
	GetInstanceMetrics(ctx context.Context, vmId int, params *GetInstanceMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostInstanceResizeWithBody request with any body
	PostInstanceResizeWithBody(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostInstanceResize(ctx context.Context, vmId int, body PostInstanceResizeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSecurityRuleWithBody request with any body
	PostSecurityRuleWithBody(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSecurityRule(ctx context.Context, vmId int, body PostSecurityRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSecurityRule request
	DeleteSecurityRule(ctx context.Context, vmId int, sgRuleId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSnapshotsWithBody request with any body
	PostSnapshotsWithBody(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSnapshots(ctx context.Context, vmId int, body PostSnapshotsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInstance4 request
	GetInstance4(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInstance5 request
	GetInstance5(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetInstance(ctx context.Context, params *GetInstanceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInstanceRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostInstanceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostInstanceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostInstance(ctx context.Context, body PostInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostInstanceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetContractInstances(ctx context.Context, contractId int, params *GetContractInstancesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetContractInstancesRequest(c.Server, contractId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FetchVirtualMachineNameAvailability(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFetchVirtualMachineNameAvailabilityRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteInstance(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteInstanceRequest(c.Server, vmId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInstance2(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInstance2Request(c.Server, vmId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostInstanceAttachFirewallsWithBody(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostInstanceAttachFirewallsRequestWithBody(c.Server, vmId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostInstanceAttachFirewalls(ctx context.Context, vmId int, body PostInstanceAttachFirewallsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostInstanceAttachFirewallsRequest(c.Server, vmId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInstance3(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInstance3Request(c.Server, vmId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInstanceHibernate(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInstanceHibernateRequest(c.Server, vmId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInstanceHibernateRestore(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInstanceHibernateRestoreRequest(c.Server, vmId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutLabelsWithBody(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutLabelsRequestWithBody(c.Server, vmId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutLabels(ctx context.Context, vmId int, body PutLabelsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutLabelsRequest(c.Server, vmId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInstanceLogs(ctx context.Context, vmId int, params *GetInstanceLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInstanceLogsRequest(c.Server, vmId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostInstanceLogsWithBody(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostInstanceLogsRequestWithBody(c.Server, vmId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostInstanceLogs(ctx context.Context, vmId int, body PostInstanceLogsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostInstanceLogsRequest(c.Server, vmId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInstanceMetrics(ctx context.Context, vmId int, params *GetInstanceMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInstanceMetricsRequest(c.Server, vmId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostInstanceResizeWithBody(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostInstanceResizeRequestWithBody(c.Server, vmId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostInstanceResize(ctx context.Context, vmId int, body PostInstanceResizeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostInstanceResizeRequest(c.Server, vmId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSecurityRuleWithBody(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSecurityRuleRequestWithBody(c.Server, vmId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSecurityRule(ctx context.Context, vmId int, body PostSecurityRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSecurityRuleRequest(c.Server, vmId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSecurityRule(ctx context.Context, vmId int, sgRuleId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSecurityRuleRequest(c.Server, vmId, sgRuleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSnapshotsWithBody(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSnapshotsRequestWithBody(c.Server, vmId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSnapshots(ctx context.Context, vmId int, body PostSnapshotsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSnapshotsRequest(c.Server, vmId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInstance4(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInstance4Request(c.Server, vmId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInstance5(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInstance5Request(c.Server, vmId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetInstanceRequest generates requests for GetInstance
func NewGetInstanceRequest(server string, params *GetInstanceParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Environment != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "environment", runtime.ParamLocationQuery, *params.Environment); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeFirewalls != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_firewalls", runtime.ParamLocationQuery, *params.ExcludeFirewalls); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostInstanceRequest calls the generic PostInstance builder with application/json body
func NewPostInstanceRequest(server string, body PostInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostInstanceRequestWithBody(server, "application/json", bodyReader)
}

// NewPostInstanceRequestWithBody generates requests for PostInstance with any type of body
func NewPostInstanceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetContractInstancesRequest generates requests for GetContractInstances
func NewGetContractInstancesRequest(server string, contractId int, params *GetContractInstancesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "contract_id", runtime.ParamLocationPath, contractId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/contract/%s/virtual-machines", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFetchVirtualMachineNameAvailabilityRequest generates requests for FetchVirtualMachineNameAvailability
func NewFetchVirtualMachineNameAvailabilityRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/name-availability/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteInstanceRequest generates requests for DeleteInstance
func NewDeleteInstanceRequest(server string, vmId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vm_id", runtime.ParamLocationPath, vmId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInstance2Request generates requests for GetInstance2
func NewGetInstance2Request(server string, vmId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vm_id", runtime.ParamLocationPath, vmId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostInstanceAttachFirewallsRequest calls the generic PostInstanceAttachFirewalls builder with application/json body
func NewPostInstanceAttachFirewallsRequest(server string, vmId int, body PostInstanceAttachFirewallsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostInstanceAttachFirewallsRequestWithBody(server, vmId, "application/json", bodyReader)
}

// NewPostInstanceAttachFirewallsRequestWithBody generates requests for PostInstanceAttachFirewalls with any type of body
func NewPostInstanceAttachFirewallsRequestWithBody(server string, vmId int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vm_id", runtime.ParamLocationPath, vmId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s/attach-firewalls", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetInstance3Request generates requests for GetInstance3
func NewGetInstance3Request(server string, vmId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vm_id", runtime.ParamLocationPath, vmId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s/hard-reboot", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInstanceHibernateRequest generates requests for GetInstanceHibernate
func NewGetInstanceHibernateRequest(server string, vmId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vm_id", runtime.ParamLocationPath, vmId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s/hibernate", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInstanceHibernateRestoreRequest generates requests for GetInstanceHibernateRestore
func NewGetInstanceHibernateRestoreRequest(server string, vmId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vm_id", runtime.ParamLocationPath, vmId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s/hibernate-restore", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutLabelsRequest calls the generic PutLabels builder with application/json body
func NewPutLabelsRequest(server string, vmId int, body PutLabelsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutLabelsRequestWithBody(server, vmId, "application/json", bodyReader)
}

// NewPutLabelsRequestWithBody generates requests for PutLabels with any type of body
func NewPutLabelsRequestWithBody(server string, vmId int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vm_id", runtime.ParamLocationPath, vmId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s/label", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetInstanceLogsRequest generates requests for GetInstanceLogs
func NewGetInstanceLogsRequest(server string, vmId int, params *GetInstanceLogsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vm_id", runtime.ParamLocationPath, vmId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s/logs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "request_id", runtime.ParamLocationQuery, params.RequestId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostInstanceLogsRequest calls the generic PostInstanceLogs builder with application/json body
func NewPostInstanceLogsRequest(server string, vmId int, body PostInstanceLogsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostInstanceLogsRequestWithBody(server, vmId, "application/json", bodyReader)
}

// NewPostInstanceLogsRequestWithBody generates requests for PostInstanceLogs with any type of body
func NewPostInstanceLogsRequestWithBody(server string, vmId int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vm_id", runtime.ParamLocationPath, vmId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s/logs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetInstanceMetricsRequest generates requests for GetInstanceMetrics
func NewGetInstanceMetricsRequest(server string, vmId int, params *GetInstanceMetricsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vm_id", runtime.ParamLocationPath, vmId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s/metrics", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Duration != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "duration", runtime.ParamLocationQuery, *params.Duration); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostInstanceResizeRequest calls the generic PostInstanceResize builder with application/json body
func NewPostInstanceResizeRequest(server string, vmId int, body PostInstanceResizeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostInstanceResizeRequestWithBody(server, vmId, "application/json", bodyReader)
}

// NewPostInstanceResizeRequestWithBody generates requests for PostInstanceResize with any type of body
func NewPostInstanceResizeRequestWithBody(server string, vmId int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vm_id", runtime.ParamLocationPath, vmId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s/resize", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostSecurityRuleRequest calls the generic PostSecurityRule builder with application/json body
func NewPostSecurityRuleRequest(server string, vmId int, body PostSecurityRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSecurityRuleRequestWithBody(server, vmId, "application/json", bodyReader)
}

// NewPostSecurityRuleRequestWithBody generates requests for PostSecurityRule with any type of body
func NewPostSecurityRuleRequestWithBody(server string, vmId int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vm_id", runtime.ParamLocationPath, vmId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s/sg-rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSecurityRuleRequest generates requests for DeleteSecurityRule
func NewDeleteSecurityRuleRequest(server string, vmId int, sgRuleId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vm_id", runtime.ParamLocationPath, vmId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sg_rule_id", runtime.ParamLocationPath, sgRuleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s/sg-rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSnapshotsRequest calls the generic PostSnapshots builder with application/json body
func NewPostSnapshotsRequest(server string, vmId int, body PostSnapshotsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSnapshotsRequestWithBody(server, vmId, "application/json", bodyReader)
}

// NewPostSnapshotsRequestWithBody generates requests for PostSnapshots with any type of body
func NewPostSnapshotsRequestWithBody(server string, vmId int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vm_id", runtime.ParamLocationPath, vmId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s/snapshots", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetInstance4Request generates requests for GetInstance4
func NewGetInstance4Request(server string, vmId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vm_id", runtime.ParamLocationPath, vmId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s/start", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInstance5Request generates requests for GetInstance5
func NewGetInstance5Request(server string, vmId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vm_id", runtime.ParamLocationPath, vmId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/virtual-machines/%s/stop", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetInstanceWithResponse request
	GetInstanceWithResponse(ctx context.Context, params *GetInstanceParams, reqEditors ...RequestEditorFn) (*GetInstanceResponse, error)

	// PostInstanceWithBodyWithResponse request with any body
	PostInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostInstanceResponse, error)

	PostInstanceWithResponse(ctx context.Context, body PostInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*PostInstanceResponse, error)

	// GetContractInstancesWithResponse request
	GetContractInstancesWithResponse(ctx context.Context, contractId int, params *GetContractInstancesParams, reqEditors ...RequestEditorFn) (*GetContractInstancesResponse, error)

	// FetchVirtualMachineNameAvailabilityWithResponse request
	FetchVirtualMachineNameAvailabilityWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*FetchVirtualMachineNameAvailabilityResponse, error)

	// DeleteInstanceWithResponse request
	DeleteInstanceWithResponse(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*DeleteInstanceResponse, error)

	// GetInstance2WithResponse request
	GetInstance2WithResponse(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*GetInstance2Response, error)

	// PostInstanceAttachFirewallsWithBodyWithResponse request with any body
	PostInstanceAttachFirewallsWithBodyWithResponse(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostInstanceAttachFirewallsResponse, error)

	PostInstanceAttachFirewallsWithResponse(ctx context.Context, vmId int, body PostInstanceAttachFirewallsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostInstanceAttachFirewallsResponse, error)

	// GetInstance3WithResponse request
	GetInstance3WithResponse(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*GetInstance3Response, error)

	// GetInstanceHibernateWithResponse request
	GetInstanceHibernateWithResponse(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*GetInstanceHibernateResponse, error)

	// GetInstanceHibernateRestoreWithResponse request
	GetInstanceHibernateRestoreWithResponse(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*GetInstanceHibernateRestoreResponse, error)

	// PutLabelsWithBodyWithResponse request with any body
	PutLabelsWithBodyWithResponse(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutLabelsResponse, error)

	PutLabelsWithResponse(ctx context.Context, vmId int, body PutLabelsJSONRequestBody, reqEditors ...RequestEditorFn) (*PutLabelsResponse, error)

	// GetInstanceLogsWithResponse request
	GetInstanceLogsWithResponse(ctx context.Context, vmId int, params *GetInstanceLogsParams, reqEditors ...RequestEditorFn) (*GetInstanceLogsResponse, error)

	// PostInstanceLogsWithBodyWithResponse request with any body
	PostInstanceLogsWithBodyWithResponse(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostInstanceLogsResponse, error)

	PostInstanceLogsWithResponse(ctx context.Context, vmId int, body PostInstanceLogsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostInstanceLogsResponse, error)

	// GetInstanceMetricsWithResponse request
	GetInstanceMetricsWithResponse(ctx context.Context, vmId int, params *GetInstanceMetricsParams, reqEditors ...RequestEditorFn) (*GetInstanceMetricsResponse, error)

	// PostInstanceResizeWithBodyWithResponse request with any body
	PostInstanceResizeWithBodyWithResponse(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostInstanceResizeResponse, error)

	PostInstanceResizeWithResponse(ctx context.Context, vmId int, body PostInstanceResizeJSONRequestBody, reqEditors ...RequestEditorFn) (*PostInstanceResizeResponse, error)

	// PostSecurityRuleWithBodyWithResponse request with any body
	PostSecurityRuleWithBodyWithResponse(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSecurityRuleResponse, error)

	PostSecurityRuleWithResponse(ctx context.Context, vmId int, body PostSecurityRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSecurityRuleResponse, error)

	// DeleteSecurityRuleWithResponse request
	DeleteSecurityRuleWithResponse(ctx context.Context, vmId int, sgRuleId int, reqEditors ...RequestEditorFn) (*DeleteSecurityRuleResponse, error)

	// PostSnapshotsWithBodyWithResponse request with any body
	PostSnapshotsWithBodyWithResponse(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSnapshotsResponse, error)

	PostSnapshotsWithResponse(ctx context.Context, vmId int, body PostSnapshotsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSnapshotsResponse, error)

	// GetInstance4WithResponse request
	GetInstance4WithResponse(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*GetInstance4Response, error)

	// GetInstance5WithResponse request
	GetInstance5WithResponse(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*GetInstance5Response, error)
}

type GetInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Instances
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r GetInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateInstancesResponse
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
	JSON405      *ErrorResponseModel
	JSON409      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r PostInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetContractInstancesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContractInstancesResponse
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r GetContractInstancesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContractInstancesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FetchVirtualMachineNameAvailabilityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NameAvailableModel
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r FetchVirtualMachineNameAvailabilityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchVirtualMachineNameAvailabilityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseModel
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
	JSON409      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r DeleteInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInstance2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Instance
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r GetInstance2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInstance2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostInstanceAttachFirewallsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseModel
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r PostInstanceAttachFirewallsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostInstanceAttachFirewallsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInstance3Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseModel
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r GetInstance3Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInstance3Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInstanceHibernateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseModel
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r GetInstanceHibernateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInstanceHibernateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInstanceHibernateRestoreResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseModel
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r GetInstanceHibernateRestoreResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInstanceHibernateRestoreResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutLabelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseModel
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
	JSON409      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r PutLabelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutLabelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInstanceLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetInstanceLogsData
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
	JSON405      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r GetInstanceLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInstanceLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostInstanceLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RequestInstanceLogsResponse
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
	JSON405      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r PostInstanceLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostInstanceLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInstanceMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetricsFields
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
	JSON406      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r GetInstanceMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInstanceMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostInstanceResizeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseModel
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
	JSON405      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r PostInstanceResizeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostInstanceResizeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSecurityRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SecurityGroupRule
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
	JSON409      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r PostSecurityRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSecurityRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSecurityRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseModel
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r DeleteSecurityRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSecurityRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSnapshotsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CreateSnapshotResponse
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r PostSnapshotsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSnapshotsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInstance4Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseModel
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r GetInstance4Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInstance4Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInstance5Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseModel
	JSON400      *ErrorResponseModel
	JSON401      *ErrorResponseModel
	JSON404      *ErrorResponseModel
}

// Status returns HTTPResponse.Status
func (r GetInstance5Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInstance5Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetInstanceWithResponse request returning *GetInstanceResponse
func (c *ClientWithResponses) GetInstanceWithResponse(ctx context.Context, params *GetInstanceParams, reqEditors ...RequestEditorFn) (*GetInstanceResponse, error) {
	rsp, err := c.GetInstance(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInstanceResponse(rsp)
}

// PostInstanceWithBodyWithResponse request with arbitrary body returning *PostInstanceResponse
func (c *ClientWithResponses) PostInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostInstanceResponse, error) {
	rsp, err := c.PostInstanceWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostInstanceResponse(rsp)
}

func (c *ClientWithResponses) PostInstanceWithResponse(ctx context.Context, body PostInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*PostInstanceResponse, error) {
	rsp, err := c.PostInstance(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostInstanceResponse(rsp)
}

// GetContractInstancesWithResponse request returning *GetContractInstancesResponse
func (c *ClientWithResponses) GetContractInstancesWithResponse(ctx context.Context, contractId int, params *GetContractInstancesParams, reqEditors ...RequestEditorFn) (*GetContractInstancesResponse, error) {
	rsp, err := c.GetContractInstances(ctx, contractId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetContractInstancesResponse(rsp)
}

// FetchVirtualMachineNameAvailabilityWithResponse request returning *FetchVirtualMachineNameAvailabilityResponse
func (c *ClientWithResponses) FetchVirtualMachineNameAvailabilityWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*FetchVirtualMachineNameAvailabilityResponse, error) {
	rsp, err := c.FetchVirtualMachineNameAvailability(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFetchVirtualMachineNameAvailabilityResponse(rsp)
}

// DeleteInstanceWithResponse request returning *DeleteInstanceResponse
func (c *ClientWithResponses) DeleteInstanceWithResponse(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*DeleteInstanceResponse, error) {
	rsp, err := c.DeleteInstance(ctx, vmId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteInstanceResponse(rsp)
}

// GetInstance2WithResponse request returning *GetInstance2Response
func (c *ClientWithResponses) GetInstance2WithResponse(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*GetInstance2Response, error) {
	rsp, err := c.GetInstance2(ctx, vmId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInstance2Response(rsp)
}

// PostInstanceAttachFirewallsWithBodyWithResponse request with arbitrary body returning *PostInstanceAttachFirewallsResponse
func (c *ClientWithResponses) PostInstanceAttachFirewallsWithBodyWithResponse(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostInstanceAttachFirewallsResponse, error) {
	rsp, err := c.PostInstanceAttachFirewallsWithBody(ctx, vmId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostInstanceAttachFirewallsResponse(rsp)
}

func (c *ClientWithResponses) PostInstanceAttachFirewallsWithResponse(ctx context.Context, vmId int, body PostInstanceAttachFirewallsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostInstanceAttachFirewallsResponse, error) {
	rsp, err := c.PostInstanceAttachFirewalls(ctx, vmId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostInstanceAttachFirewallsResponse(rsp)
}

// GetInstance3WithResponse request returning *GetInstance3Response
func (c *ClientWithResponses) GetInstance3WithResponse(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*GetInstance3Response, error) {
	rsp, err := c.GetInstance3(ctx, vmId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInstance3Response(rsp)
}

// GetInstanceHibernateWithResponse request returning *GetInstanceHibernateResponse
func (c *ClientWithResponses) GetInstanceHibernateWithResponse(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*GetInstanceHibernateResponse, error) {
	rsp, err := c.GetInstanceHibernate(ctx, vmId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInstanceHibernateResponse(rsp)
}

// GetInstanceHibernateRestoreWithResponse request returning *GetInstanceHibernateRestoreResponse
func (c *ClientWithResponses) GetInstanceHibernateRestoreWithResponse(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*GetInstanceHibernateRestoreResponse, error) {
	rsp, err := c.GetInstanceHibernateRestore(ctx, vmId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInstanceHibernateRestoreResponse(rsp)
}

// PutLabelsWithBodyWithResponse request with arbitrary body returning *PutLabelsResponse
func (c *ClientWithResponses) PutLabelsWithBodyWithResponse(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutLabelsResponse, error) {
	rsp, err := c.PutLabelsWithBody(ctx, vmId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutLabelsResponse(rsp)
}

func (c *ClientWithResponses) PutLabelsWithResponse(ctx context.Context, vmId int, body PutLabelsJSONRequestBody, reqEditors ...RequestEditorFn) (*PutLabelsResponse, error) {
	rsp, err := c.PutLabels(ctx, vmId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutLabelsResponse(rsp)
}

// GetInstanceLogsWithResponse request returning *GetInstanceLogsResponse
func (c *ClientWithResponses) GetInstanceLogsWithResponse(ctx context.Context, vmId int, params *GetInstanceLogsParams, reqEditors ...RequestEditorFn) (*GetInstanceLogsResponse, error) {
	rsp, err := c.GetInstanceLogs(ctx, vmId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInstanceLogsResponse(rsp)
}

// PostInstanceLogsWithBodyWithResponse request with arbitrary body returning *PostInstanceLogsResponse
func (c *ClientWithResponses) PostInstanceLogsWithBodyWithResponse(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostInstanceLogsResponse, error) {
	rsp, err := c.PostInstanceLogsWithBody(ctx, vmId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostInstanceLogsResponse(rsp)
}

func (c *ClientWithResponses) PostInstanceLogsWithResponse(ctx context.Context, vmId int, body PostInstanceLogsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostInstanceLogsResponse, error) {
	rsp, err := c.PostInstanceLogs(ctx, vmId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostInstanceLogsResponse(rsp)
}

// GetInstanceMetricsWithResponse request returning *GetInstanceMetricsResponse
func (c *ClientWithResponses) GetInstanceMetricsWithResponse(ctx context.Context, vmId int, params *GetInstanceMetricsParams, reqEditors ...RequestEditorFn) (*GetInstanceMetricsResponse, error) {
	rsp, err := c.GetInstanceMetrics(ctx, vmId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInstanceMetricsResponse(rsp)
}

// PostInstanceResizeWithBodyWithResponse request with arbitrary body returning *PostInstanceResizeResponse
func (c *ClientWithResponses) PostInstanceResizeWithBodyWithResponse(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostInstanceResizeResponse, error) {
	rsp, err := c.PostInstanceResizeWithBody(ctx, vmId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostInstanceResizeResponse(rsp)
}

func (c *ClientWithResponses) PostInstanceResizeWithResponse(ctx context.Context, vmId int, body PostInstanceResizeJSONRequestBody, reqEditors ...RequestEditorFn) (*PostInstanceResizeResponse, error) {
	rsp, err := c.PostInstanceResize(ctx, vmId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostInstanceResizeResponse(rsp)
}

// PostSecurityRuleWithBodyWithResponse request with arbitrary body returning *PostSecurityRuleResponse
func (c *ClientWithResponses) PostSecurityRuleWithBodyWithResponse(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSecurityRuleResponse, error) {
	rsp, err := c.PostSecurityRuleWithBody(ctx, vmId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSecurityRuleResponse(rsp)
}

func (c *ClientWithResponses) PostSecurityRuleWithResponse(ctx context.Context, vmId int, body PostSecurityRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSecurityRuleResponse, error) {
	rsp, err := c.PostSecurityRule(ctx, vmId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSecurityRuleResponse(rsp)
}

// DeleteSecurityRuleWithResponse request returning *DeleteSecurityRuleResponse
func (c *ClientWithResponses) DeleteSecurityRuleWithResponse(ctx context.Context, vmId int, sgRuleId int, reqEditors ...RequestEditorFn) (*DeleteSecurityRuleResponse, error) {
	rsp, err := c.DeleteSecurityRule(ctx, vmId, sgRuleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSecurityRuleResponse(rsp)
}

// PostSnapshotsWithBodyWithResponse request with arbitrary body returning *PostSnapshotsResponse
func (c *ClientWithResponses) PostSnapshotsWithBodyWithResponse(ctx context.Context, vmId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSnapshotsResponse, error) {
	rsp, err := c.PostSnapshotsWithBody(ctx, vmId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSnapshotsResponse(rsp)
}

func (c *ClientWithResponses) PostSnapshotsWithResponse(ctx context.Context, vmId int, body PostSnapshotsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSnapshotsResponse, error) {
	rsp, err := c.PostSnapshots(ctx, vmId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSnapshotsResponse(rsp)
}

// GetInstance4WithResponse request returning *GetInstance4Response
func (c *ClientWithResponses) GetInstance4WithResponse(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*GetInstance4Response, error) {
	rsp, err := c.GetInstance4(ctx, vmId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInstance4Response(rsp)
}

// GetInstance5WithResponse request returning *GetInstance5Response
func (c *ClientWithResponses) GetInstance5WithResponse(ctx context.Context, vmId int, reqEditors ...RequestEditorFn) (*GetInstance5Response, error) {
	rsp, err := c.GetInstance5(ctx, vmId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInstance5Response(rsp)
}

// ParseGetInstanceResponse parses an HTTP response from a GetInstanceWithResponse call
func ParseGetInstanceResponse(rsp *http.Response) (*GetInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Instances
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParsePostInstanceResponse parses an HTTP response from a PostInstanceWithResponse call
func ParsePostInstanceResponse(rsp *http.Response) (*PostInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateInstancesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetContractInstancesResponse parses an HTTP response from a GetContractInstancesWithResponse call
func ParseGetContractInstancesResponse(rsp *http.Response) (*GetContractInstancesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetContractInstancesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContractInstancesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFetchVirtualMachineNameAvailabilityResponse parses an HTTP response from a FetchVirtualMachineNameAvailabilityWithResponse call
func ParseFetchVirtualMachineNameAvailabilityResponse(rsp *http.Response) (*FetchVirtualMachineNameAvailabilityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FetchVirtualMachineNameAvailabilityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NameAvailableModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteInstanceResponse parses an HTTP response from a DeleteInstanceWithResponse call
func ParseDeleteInstanceResponse(rsp *http.Response) (*DeleteInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetInstance2Response parses an HTTP response from a GetInstance2WithResponse call
func ParseGetInstance2Response(rsp *http.Response) (*GetInstance2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInstance2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Instance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePostInstanceAttachFirewallsResponse parses an HTTP response from a PostInstanceAttachFirewallsWithResponse call
func ParsePostInstanceAttachFirewallsResponse(rsp *http.Response) (*PostInstanceAttachFirewallsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostInstanceAttachFirewallsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetInstance3Response parses an HTTP response from a GetInstance3WithResponse call
func ParseGetInstance3Response(rsp *http.Response) (*GetInstance3Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInstance3Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetInstanceHibernateResponse parses an HTTP response from a GetInstanceHibernateWithResponse call
func ParseGetInstanceHibernateResponse(rsp *http.Response) (*GetInstanceHibernateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInstanceHibernateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetInstanceHibernateRestoreResponse parses an HTTP response from a GetInstanceHibernateRestoreWithResponse call
func ParseGetInstanceHibernateRestoreResponse(rsp *http.Response) (*GetInstanceHibernateRestoreResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInstanceHibernateRestoreResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePutLabelsResponse parses an HTTP response from a PutLabelsWithResponse call
func ParsePutLabelsResponse(rsp *http.Response) (*PutLabelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutLabelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetInstanceLogsResponse parses an HTTP response from a GetInstanceLogsWithResponse call
func ParseGetInstanceLogsResponse(rsp *http.Response) (*GetInstanceLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInstanceLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetInstanceLogsData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParsePostInstanceLogsResponse parses an HTTP response from a PostInstanceLogsWithResponse call
func ParsePostInstanceLogsResponse(rsp *http.Response) (*PostInstanceLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostInstanceLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RequestInstanceLogsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseGetInstanceMetricsResponse parses an HTTP response from a GetInstanceMetricsWithResponse call
func ParseGetInstanceMetricsResponse(rsp *http.Response) (*GetInstanceMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInstanceMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetricsFields
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParsePostInstanceResizeResponse parses an HTTP response from a PostInstanceResizeWithResponse call
func ParsePostInstanceResizeResponse(rsp *http.Response) (*PostInstanceResizeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostInstanceResizeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParsePostSecurityRuleResponse parses an HTTP response from a PostSecurityRuleWithResponse call
func ParsePostSecurityRuleResponse(rsp *http.Response) (*PostSecurityRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSecurityRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SecurityGroupRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseDeleteSecurityRuleResponse parses an HTTP response from a DeleteSecurityRuleWithResponse call
func ParseDeleteSecurityRuleResponse(rsp *http.Response) (*DeleteSecurityRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSecurityRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePostSnapshotsResponse parses an HTTP response from a PostSnapshotsWithResponse call
func ParsePostSnapshotsResponse(rsp *http.Response) (*PostSnapshotsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSnapshotsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateSnapshotResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetInstance4Response parses an HTTP response from a GetInstance4WithResponse call
func ParseGetInstance4Response(rsp *http.Response) (*GetInstance4Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInstance4Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetInstance5Response parses an HTTP response from a GetInstance5WithResponse call
func ParseGetInstance5Response(rsp *http.Response) (*GetInstance5Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInstance5Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}
